{"meta":{"title":"Micoael_Primo","subtitle":"blog of juruo","description":"我太弱了","author":"MP","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"不等数列题解","slug":"不等数列题解","date":"2020-09-03T05:40:10.000Z","updated":"2020-09-03T05:45:25.972Z","comments":true,"path":"2020/09/03/不等数列题解/","link":"","permalink":"http://example.com/2020/09/03/%E4%B8%8D%E7%AD%89%E6%95%B0%E5%88%97%E9%A2%98%E8%A7%A3/","excerpt":"今天模拟赛正好做到了这道题。不难发现这是一道递推的题目。 在考试时候的做法 首先保证自己的部分分可以拿到。 观察数据范围$n\\leq 10$. 枚举复杂度$\\mathcal O(n!)$. 利用C++ algorithm里面的的next_permutation不难写出暴力代码。","text":"今天模拟赛正好做到了这道题。不难发现这是一道递推的题目。 在考试时候的做法 首先保证自己的部分分可以拿到。 观察数据范围$n\\leq 10$. 枚举复杂度$\\mathcal O(n!)$. 利用C++ algorithm里面的的next_permutation不难写出暴力代码。 考虑正解 定义状态$f[i][j]$表示考虑前面$i$个数字，有$j$个$&lt;$符号。 我们观察这样有什么性质： 性质1. 假设当前排序列为$a$如果考虑第$i+1$个数字的时候，$\\forall a[x]&lt;(i+1), x\\in[0,i]$. 非形式化的. 由$i$转移到$i+1$的时候，$i+1$号元素是这个序列里面最大的一个数。 说明. 根据定义，$f[i][j]$表示仅仅考虑前$i$个数字，则每一项不会超过$i$.转移时需要考虑$i+1$号数字参与进来的情况。因为$i+1&gt;i$,原式成立。 性质2. 考虑一个长度为$i$排列好的序列。其中有$j$个小于号。考虑将第$i+1$个数插入序列之后，小于号的个数只会不变或者增加$1$.并且有$i-j$种情况使得小于号的数量会增加1，有$j+1$种情况使得小于号数量不变。 说明. 分类讨论： 假设插入的数落在$x,y$之间。 且$x&gt;y$. 设插入的数为$t$。插入之后大小变化为$xy$.小于号数目增加了1. $(1)$ 且$x&lt;y$. 设插入的数为$t$。插入之后大小变化为$xy$.小于号数量不发生改变。 $(2)$ 假设插入的数在开头。并且设开头的数为$x$ 设插入的数为$t$. 由性质1可以得到：$t&gt;x$.小于号数量不变。 $(3)$ 假设插入的数在结尾。并且设开头的数为$y$ 设插入的数为$t$. 由性质1可以得到：$y&lt;t$.小于号数量增加了1。 $(4)$ 由于$f[i][j]$表示前$i$个字符中小于号有$j$个，不难得到大于号的个数为$i-j-1$. 考虑$i-1 \\to i$的转移使得小于号数量增多1的有$(i-j-1)+(1)=i-j$(情况1和4)。不变的有$(j+1)$个。（情况2和情况3） 由于计数原理（加乘原理），可以发现： f[i][j] = f[i-1][j]\\times (j+1)+f[i-1][j-1]\\times (i-j) 得到正解。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define MOD 2015using namespace std;int f[1005][1005];inline int read()&#123; int x; x=0;char ch=0;bool sign=false; while(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;)&#123; sign|=(ch == &#x27;-&#x27;); ch=getchar(); &#125; while(!(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;))&#123; x=x*10+(ch^48); ch=getchar(); &#125; x=sign ? -x : x; return x;&#125;inline void print(int x)&#123; if(x&lt;0)putchar(&#x27;-&#x27;),x=-x; if(x&gt;9)print(x/10); putchar(x%10+&#x27;0&#x27;);&#125;int main()&#123; for(int i=0;i&lt;1005;i++)&#123; f[i][0] = 1; &#125; for(int i=1;i&lt;1005;i++)&#123; for(int j=1;j&lt;1005;j++)&#123; f[i][j] = (f[i-1][j-1]*(i-j) + f[i-1][j]*(j+1))%MOD; &#125; &#125; int n=read(),p=read(); printf(&quot;%d\\n&quot;,f[n][p]); return 0;&#125; 总结需要在DP的时候多多观察原始式子和状态的定义和其拥有的性质，才可以高速解决。","categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://example.com/tags/DP/"}]},{"title":"NOIP试题研究","slug":"OI试题研究","date":"2020-09-02T13:39:40.000Z","updated":"2020-09-02T13:32:24.305Z","comments":true,"path":"2020/09/02/OI试题研究/","link":"","permalink":"http://example.com/2020/09/02/OI%E8%AF%95%E9%A2%98%E7%A0%94%E7%A9%B6/","excerpt":"NOIP试题研究上古时期的NOIP进制位 [容易,结论] 结论题 每一行有几个二位数，这个数就是几。","text":"NOIP试题研究上古时期的NOIP进制位 [容易,结论] 结论题 每一行有几个二位数，这个数就是几。 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;int n,ans[15],mp[26];char s[15][15][3];inline bool check(int x,int y)&#123; int sum=ans[x]+ans[y]; int cur=s[x][y][1]-&#x27;A&#x27;; if (sum&gt;=n-1 &amp;&amp; mp[cur]!=1) return 0; if (sum&gt;=n-1) sum-=n-1,cur=s[x][y][2]-&#x27;A&#x27;; if (mp[cur]!=sum) return 0; return 1;&#125;int main()&#123; cin&gt;&gt;n; for (int j=1;j&lt;=n;j++) scanf(&quot;%s&quot;,s[1][j]+1); for (int i=2;i&lt;=n;i++)&#123; int cnt=0; for (int j=1;j&lt;=n;j++)&#123; scanf(&quot;%s&quot;,s[i][j]+1); cnt+=strlen(s[i][j]+1)&gt;=2; &#125; ans[i]=cnt; mp[s[i][1][1]-&#x27;A&#x27;]=cnt; &#125; for (int i=2;i&lt;=n;i++) for (int j=2;j&lt;=n;j++) if (!check(i,j)) return 0&amp;puts(&quot;ERROR!&quot;); for (int i=2;i&lt;=n;i++) printf(&quot;%c=%d &quot;,s[i][1][1],ans[i]); return !printf(&quot;\\n%d&quot;,n-1);&#125; 统计单词个数 [难,dp] 今天了解这是一个字符串dp 网上说这种题一般要定义状态$f[i][j]$是母串$i$位置$j$块的大小。 做题的时候发现对于说this包含this和is 但不包含th这也就是说在一个串内这句话不太理解。 考虑性质，发现字符串匹配，不知道该怎么办。 查看题解，发现： 假设我们已经预处理好了$[l,r]$的单词数。记为$\\text{dp2}[l][r]$ 那么考虑前一块已经分好了的情况。然后考虑倒着枚举下一块。从$[0,r-1]$枚举。 显然有：状态 $\\large dp[0][i]=0\\quad ,dp[i][1]=dp2[1][\\text{i}]$ $\\large dp[i][i] = dp[i-1][i-1]+dp2[i][i]$ $\\large dp[i][j]= \\max(dp[i-r-1][j-1]+dp2[i-r][j],dp[i][j])$ 那么答案就是：$dp[\\text{len}][k]$ 那么我们怎么保证处理$dp2$? 可以倒着推。（说this包含this和is 但不包含th这也就是说在一个串内）给予的提示。 不难发现： \\large dp2[i][j] = \\{ \\begin{aligned} &dp2[i+1][j]+1 &(\\text{存在从A[i]开始的单词}) \\\\ &dp2[i+1][j]&(其他情况) \\end{aligned} 如果有许多个，根据刚才的性质，不难发现还需要+1就行了。 注意 状态转移方程在寻找的时候： 在状态里面的状态需要写出详细的意思 不在状态范围里面的要写出取值范围以及表示的意义。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;stdio.h&gt;#include &lt;bits/stdc++.h&gt;#include&lt;string.h&gt;using namespace std;int p=0,k=0,s=0,len=0,dp2[205][205]=&#123;&#125;,dp[205][45]=&#123;&#125;;char A[205]=&#123;&#125;,temp[25]=&#123;&#125;,word[10][205]=&#123;&#125;;void Input(void)&#123; string ch; s+=&#x27;0&#x27;; cin&gt;&gt;p&gt;&gt;k; for(int i=1;i&lt;=p;i++)&#123; cin&gt;&gt;ch; s=ch; &#125; cin&gt;&gt;n;m=s.length()-1; for(int i=1;i&lt;=n;i++)cin&gt;&gt;word[i];&#125;int have(int x,int end)&#123; int i=0; for(i=1;i&lt;=s;i++)&#123; char *p=strstr(&amp;A[x],word[i]); if(p!=NULL &amp;&amp; p-&amp;A[x]==0 &amp;&amp; (int)strlen(word[i]) &lt;=end-x+1) return 1; &#125; return 0;&#125;void dp1()&#123; int i=0,j=0; // Enum from dest for(j=len;j&gt;=1;j--) for(i=j;i&gt;=1;i--) if(have(i,j)) dp2[i][j]=dp2[i+1][j]+1; else dp2[i][j]=dp2[i+1][j]; /* for(int i=len;i&gt;=1;i--)&#123; for(int j=i;j&gt;=1;j--)&#123; if(have(i,j))&#123; dp2[i][j] = dp2[i+1][j]+1; &#125;else&#123; dp2[i][j] = dp2[i+1][j]; &#125; &#125; &#125; */&#125;void dp22()&#123; for(int i=1;i&lt;=k;i++)&#123; dp[i][i] = dp[i-1][i-1] + dp2[i][i]; &#125; for(int i=1;i&lt;=len;i++)&#123; dp[i][1] = dp2[1][i]; &#125; for(int i=1;i&lt;=len;i++)&#123; for(int j=2;j&lt;=k &amp;&amp; j&lt;=i;j++)&#123;// for(int r=1;r&lt;i;r++)&#123;// dp[i][j] = max(dp[i-r-1][j-1]+dp2[i-r][i],dp[i][j]);// &#125; for(int r=j;r&lt;i;r++) if(dp[i][j]&lt;dp[r][j-1]+dp2[r+1][i]) dp[i][j]=dp[r][j-1]+dp2[r+1][i]; &#125; &#125;&#125;int main()&#123; memset(dp,0,sizeof dp); memset(dp2,0,sizeof dp2);// freopen(&quot;D:\\\\in.txt&quot;,&quot;r&quot;,stdin); Input(); dp1(); dp22(); printf(&quot;%d\\n&quot;,dp[len][k]);&#125; Car的旅行路线 [中,最短路] 回顾：SPFA 虽然他死了但是也比Floyd强。 12345678910111213141516Q = 推入起点;vis 更新;while(!Q.empty())&#123; now = q.pop(); 清空vis标记; for 和点u相连的边m&#123; v = m.to; if(dis[v]&gt;dis[u]+edg[m].w)&#123; dis[v] = dis[u]+edg[m].w; if(vis[v]==0)&#123; Q.push(v); vis[v] = 1; &#125; &#125; &#125;&#125; 但是代码长度大。而且可多可多边。 思维难度$\\approx0$ 复习Folyd算法 12345for k=1 to n: for i =1 to n: for j=1 to n: if e[i][j]&gt;e[i][k]+e[k][j]: e[i][j] = e[i][k]+e[k][j] 建图 每4个节点为1组。 考虑连2个点的时候。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100005,maxm=500005,inf=0x3f3f3f3f;double e[1005][1005];int wz[1005][11];int n,tf;double dist(int a,int b,int c,int d)&#123; return sqrt((a-b)*(a-b)*1.0+1.0*(c-d)*(c-d));&#125;double find3(int a,int b,int c,int d)&#123; return (a-b)*(a-b)*1.0+1.0*(c-d)*(c-d);&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; int a,b; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;tf,&amp;a,&amp;b); for(int i=1;i&lt;=4*n;i++) for(int j=1;j&lt;=4*n;j++) e[i][j]=inf; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=6;j++) scanf(&quot;%d&quot;,wz[i]+j); for(int j=1;j&lt;=5;j+=2)&#123; wz[i][7]+=wz[i][j]; wz[i][8]+=wz[i][j+1]; &#125; scanf(&quot;%d&quot;,wz[i]+9); double tp[3]; int tp2=inf,tp3; tp[0]=find3(wz[i][4],wz[i][6],wz[i][3],wz[i][5]); tp[1]=find3(wz[i][2],wz[i][6],wz[i][1],wz[i][5]); tp[2]=find3(wz[i][2],wz[i][4],wz[i][1],wz[i][3]); if(tp[0]+tp[1]==tp[2])&#123; wz[i][7]-=2*wz[i][5];wz[i][8]-=2*wz[i][6]; &#125; else if(tp[1]+tp[2]==tp[0])&#123; wz[i][7]-=2*wz[i][1];wz[i][8]-=2*wz[i][2]; &#125; else if(tp[0]+tp[2]==tp[1])&#123; wz[i][7]-=2*wz[i][3];wz[i][8]-=2*wz[i][4]; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=4;j++) for(int k=j;k&lt;=4;k++)&#123; int u=(i-1)*4+j,v=(i-1)*4+k; double dis=dist(wz[i][j*2-1],wz[i][k*2-1],wz[i][j*2],wz[i][k*2]); e[u][v]=e[v][u]=dis*wz[i][9]; &#125; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(i!=j)&#123; for(int k=1;k&lt;=4;k++) for(int l=1;l&lt;=4;l++)&#123; int u=(i-1)*4+k,v=(j-1)*4+l; double dis=dist(wz[i][k*2-1],wz[j][l*2-1],wz[i][k*2],wz[j][l*2]); e[u][v]=dis*tf; &#125; &#125; for(int k=1;k&lt;=n*4;k++) for(int i=1;i&lt;=n*k;i++) for(int j=1;j&lt;=n*4;j++) if(e[i][j]&gt;e[i][k]+e[k][j]) e[i][j]=e[i][k]+e[k][j]; double ans=inf; for(int i=(a-1)*4+1;i&lt;=a*4;i++) for(int j=(b-1)*4+1;j&lt;=b*4;j++) ans=min(ans,e[i][j]); printf(&quot;%.1lf&quot;,ans); &#125; return 0;&#125; 矩形覆盖 [易,暴力枚举]/[易/选择性DP] 让我万万没想到的是，暴力搜索可以过。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#define N 55using namespace std;int n, k, x[N], y[N], ans = INT_MAX &gt;&gt; 2;struct mat &#123; int lx, ly, rx, ry; bool cnt; bool inmat(int x, int y) const &#123; return lx &lt;= x &amp;&amp; x &lt;= rx &amp;&amp; ry &lt;= y &amp;&amp; y &lt;= ly; &#125; void add(int x, int y) &#123; if(!cnt) &#123; lx = rx = x; ly = ry = y; cnt = 1; &#125; else &#123; if(x &lt; lx) lx = x; else if(x &gt; rx) rx = x; if(y &gt; ly) ly = y; else if(y &lt; ry) ry = y; &#125; &#125; int operator() () &#123; if(!cnt) return 0; return (rx - lx) * (ly - ry); &#125; bool operator* (const mat &amp;o) &#123; if(!cnt || !o.cnt) return 0; return o.inmat(lx, ly) || o.inmat(lx, ry) || o.inmat(rx, ly) || o.inmat(rx, ry); &#125;&#125; km[5];bool check() &#123; for(int i = 1;i &lt;= k;i++) for(int j = i + 1;j &lt;= k;j++) if(km[i] * km[j]) return 0; return 1;&#125;void dfs(int i, int area) &#123; if(area &gt;= ans) return; if(i == n) &#123; if(check()) if(ans &gt; area) ans = area; return; &#125; mat tmp; for(int j = 1;j &lt;= k;j++) &#123; tmp = km[j]; km[j].add(x[i], y[i]); dfs(i + 1, area - tmp() + km[j]()); km[j] = tmp; &#125;&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(int i = 0;i &lt; n;i++) scanf(&quot;%d%d&quot;, x + i, y + i); dfs(0, 0); printf(&quot;%d&quot;, ans); return 0;&#125; 显然心里有点不踏实。 题解说这是一道经典的DP题。 设$f[i][j][l]$表示第$i$个矩形$j \\rightarrow l$的最小面积。 $s[j][l]$是举行完全覆盖从$j$到$l$个点的最小面积。那么： $f(i,j,l)=\\min(f(i-1,j,m)+s(m+1,l) , j\\leq m\\leq l-1)$ 初始状态：略。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int N=55,M=9,O=0x7f;int f[M][N][N];int s[N][N];int n,k,ans=O;struct node&#123; int x,y;&#125;point[N];inline void dp()&#123; for(register int i=1;i&lt;=n;i++)&#123; int min_x=point[i].x,max_x=point[i].x,min_y=point[i].y,max_y=point[i].y; for(register int j=i+1;j&lt;=n;j++)&#123; min_x=min(min_x,point[j].x),max_x=max(max_x,point[j].x); min_y=min(min_y,point[j].y),max_y=max(max_y,point[j].y); f[1][i][j]=s[i][j]=abs(max_x-min_x)*abs(max_y-min_y); &#125; &#125; for(register int i=2;i&lt;=k;i++) for(register int j=1;j&lt;=n;j++) for(register int l=j+1;l&lt;=n;l++)&#123; f[i][j][l]=O; for(register int m=j;m&lt;l;m++) f[i][j][l]=min(f[i][j][l],f[i-1][j][m]+s[m+1][l]); &#125; ans=min(ans,f[k][1][n]);&#125;bool cmp_x(node a,node b)&#123; if(a.x^b.x) return a.x&lt;b.x; return a.y&lt;b.y;&#125;bool cmp_y(node a,node b)&#123; if(a.y^b.y) return a.y&lt;b.y; return a.x&lt;b.x;&#125;inline void work(bool step)&#123; if(step) sort(point+1,point+1+n,cmp_x); else sort(point+1,point+1+n,cmp_y); dp();&#125;void init()&#123; cin&gt;&gt;n&gt;&gt;k; for(register int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;(point[i].x);cin&gt;&gt;(point[i].y); &#125; &#125;int main()&#123; init(); work(0),work(1); printf(&quot;%d\\n&quot;,ans); return 0;&#125; 侦探推理[易,暴力枚举]/[中,2-SAT（Tarjan SCC）] 既然看到以前其他的题目中都说到要有暴力枚举，那感觉这道题也不例外。 想到枚举罪犯一一验证。一共要验证$\\large n(能过)$种情况。 神tmd题解就是枚举。 tmd这是提高组？？？！ 2-SAT问题 每一个人的真假话可能有一定的依赖关系。 不妨建立图$\\large A和A’$,跑$\\text{Tarjan SCC}$. 如果$A \\&amp; A’$在同一个集合里，那么说明不存在方案。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;int n,m,p,fake[21],err,w[200],nx;string name[100],say[200];string day[10]=&#123;&quot;0&quot;,&quot;Today is Sunday.&quot;,&quot;Today is Monday.&quot;,&quot;Today is Tuesday.&quot;,&quot;Today is Wednesday.&quot;,&quot;Today is Thursday.&quot;,&quot;Today is Friday.&quot;,&quot;Today is Saturday.&quot;,&#125;;void set(int who,int yx)&#123; if(fake[who]&amp;&amp;fake[who]!=yx)err=1; else fake[who]=yx;&#125;void input()&#123; cin&gt;&gt;m&gt;&gt;n&gt;&gt;p; for(int i=1;i&lt;=m;i++) cin&gt;&gt;name[i]; for(int i=1;i&lt;=p;i++)&#123; string nm; cin&gt;&gt;nm; nm.erase(nm.end()-1); for(int j=1;j&lt;=m;j++) if(name[j]==nm)w[i]=j; getline(cin,say[i]); say[i].erase(say[i].begin()); &#125;&#125;int main()&#123; input(); // deg for(int td=1;td&lt;=7;td++) for(int px=1;px&lt;=m;px++)&#123; err=0; memset(fake,0,sizeof(fake)); for(int i=1;i&lt;=p;i++)&#123; int who=w[i]; if(say[i]==&quot;I am guilty.&quot;)set(who,px==who?1:-1); if(say[i]==&quot;I am not guilty.&quot;)set(who,px!=who?1:-1); for(int j=1;j&lt;=7;j++) if(say[i]==day[j])set(who,j==td?1:-1); for(int j=1;j&lt;=m;j++)&#123; if(say[i]==name[j]+&quot; is guilty.&quot;)set(who,j==px?1:-1); if(say[i]==name[j]+&quot; is not guilty.&quot;)set(who,j!=px?1:-1); &#125; &#125; int cnt=0,ppp=0; for(int i=1;i&lt;=m;i++)&#123; if(fake[i]==-1)cnt++; if(fake[i]==0)ppp++; &#125; if(!err&amp;&amp;cnt&lt;=n&amp;&amp;cnt+ppp&gt;=n) if(nx&amp;&amp;nx!=px)&#123; cout&lt;&lt;&quot;Cannot Determine&quot;; return 0; &#125;else nx=px; &#125; if(!nx)cout&lt;&lt;&quot;Impossible&quot;; else cout&lt;&lt;name[nx];&#125; 注意$\\large\\text{Linux}和\\text{Windows}的换行符问题。$ 传染病控制[难,搜索] 当前传播到$i$ th gen一定要切断$i \\&amp; i+1$gen之间的关系。 考虑必须切断$i \\to i+1$之间的连边。 如果切除$i-1$层，那没什么用，白白浪费一次机会。 如果切除$i+1$层，肯定不是最优的。 错误的贪心：割掉$size$最大的，如果有相同的，就割掉度最多的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;int ans=0,n,p;vector&lt;int&gt;a[5555];struct node&#123; int now,deth,fa;&#125;;void dfs(int u,int fa)&#123; queue&lt;node&gt;q; q.push((node)&#123;1,1,0&#125;); int num=0,maxn=0,deth=2; while(!q.empty())&#123; int u=q.front().now,nowdeth=q.front().deth,fa=q.front().fa; q.pop(); if(nowdeth==deth&amp;&amp;u==num)&#123; deth++; num=0; maxn=0; continue; &#125; ans++; for(int i=0;i&lt;a[u].size();i++)&#123; int t=a[u][i]; if(t==fa) continue; if(a[t].size()&gt;maxn) &#123; maxn=a[t].size(); num=t; &#125; q.push((node)&#123;t,nowdeth+1,u&#125;); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;p; for(int i=1;i&lt;=p;i++)&#123; int x,y; cin&gt;&gt;x&gt;&gt;y; a[x].push_back(y); a[y].push_back(x); &#125; dfs(1,0); cout&lt;&lt;ans; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;int dep[4000],father[4000],son[4000],vis[4000],cnt[305][305],ans,n,p,tt[305],cntt,head[201000],ans1;struct node &#123; int u,v;&#125;a[100500];void add(int u,int v) &#123; a[++cntt].u=head[u]; head[u]=cntt; a[cntt].v=v;&#125;void dfs(int u,int fa,int deep) &#123; dep[u]=deep; son[u]=1; father[u]=fa; for (int i=head[u];i;i=a[i].u) &#123; int v=a[i].v; if(v==fa)continue; dfs(v,u,deep+1); son[u]+=son[v]; &#125;&#125;void dfs2(int u) &#123; for (int i=head[u];i;i=a[i].u) &#123; int v=a[i].v; vis[v]=1; if(v==father[u])continue; dfs2(v); &#125;&#125;void dfs3(int u) &#123; for (int i=head[u];i;i=a[i].u) &#123; int v=a[i].v; vis[v]=0; if(v==father[u])continue; dfs3(v); &#125;&#125;void dfs1(int deep) &#123; for (int i=1;i&lt;=tt[deep];i++) &#123; if(vis[father[cnt[deep][i]]]==1)continue; dfs2(cnt[deep][i]); ans+=son[cnt[deep][i]]; dfs1(deep+1); ans-=son[cnt[deep][i]]; dfs3(cnt[deep][i]); &#125; ans1=max(ans,ans1);&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;p; for (int i=1;i&lt;=p;i++) &#123; int u,v; cin&gt;&gt;u&gt;&gt;v; add(u,v); add(v,u); &#125; dfs(1,0,1); for (int i=1;i&lt;=n;i++) cnt[dep[i]][++tt[dep[i]]]=i; dfs1(2); cout&lt;&lt;n-ans1; return 0;&#125; 题解区还有使用随机化搞这道题： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;using namespace std;typedef pair&lt;int,int&gt; PII;priority_queue&lt;PII,vector&lt;PII&gt; &gt;q;const int N=305;int dis[N],nxt[N&lt;&lt;1],v[N&lt;&lt;1],head[N],tot;int siz[N],b[N],cnt,f[N];int n,p,cur,ans=333;inline void add(int x,int y)&#123; v[++tot]=y; nxt[tot]=head[x]; head[x]=tot;&#125;inline void dfs(int x,int fa)&#123; siz[x]=1; for(int i=head[x];i;i=nxt[i])&#123; int y=v[i]; if(y!=fa)&#123; f[y]=x; dfs(y,x); siz[x]+=siz[y]; &#125; &#125;&#125;queue&lt;int&gt;Q;inline void bfs(int s)&#123; while(!Q.empty())Q.pop(); Q.push(s); while(!Q.empty())&#123; cnt=0; while(!q.empty())q.pop(); while(!Q.empty())&#123; int x=Q.front();Q.pop();cur++; for(int i=head[x];i;i=nxt[i])&#123; int y=v[i]; if(y==f[x])continue; q.push(make_pair(siz[y],y)); b[++cnt]=y; &#125; &#125; int t; if(!q.empty())&#123; int y=q.top().second;q.pop(); if(!q.empty()&amp;&amp;(rand()%N==0))&#123;t=q.top().second;q.pop();&#125; else t=y; &#125; for(int i=1;i&lt;=cnt;++i)&#123; int y=b[i]; if(y!=t)Q.push(y); &#125; &#125;&#125;int main()&#123; srand(20181108); scanf(&quot;%d%d&quot;,&amp;n,&amp;p); for(int i=1;i&lt;=p;++i)&#123; int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y); add(y,x); &#125; dfs(1,1); for(int i=1;i&lt;=100000;++i)&#123; cur=0; bfs(1); ans=min(ans,cur); &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125; 过渡时期的NOIP过河[DP的优化,中等] 状态转移十分显然。 \\large dp[i+r] = \\{ \\begin{aligned} &\\min(dp[i]+1,dp[i+r]) &(\\text{a[i]是石子}) \\\\ &\\min(dp[i],dp[i+r])&(其他情况)\\\\ \\end{aligned} \\quad ,r\\in [L,R]边界条件：$dp[0]=0$ 对于全部的数据，$L\\leq 10^9$ 期望得分$30\\text{pts}$ 显然$\\text{MLE}$ DP的优化 可以首先离散化。 两点间的距离d大于t时，一定可以由d%t跳过来，所以最多只需要t+d%t种距离的状态就可以表示这两个石子之间的任意距离关系。 (画图过于生草) 123456789101112131415161718192021222324252627282930313233343536373839404142431#include&lt;bits/stdc++.h&gt;using namespace std;const int M=110,N=1e4+100;int a[M],d[M];int stone[N];int f[N];int main()&#123; int l,s,t,m; cin&gt;&gt;l&gt;&gt;s&gt;&gt;t&gt;&gt;m; int spec=-1; if(s==t)spec=0; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;a[i]; if(spec&gt;=0)spec+=!(a[i]%s); if(a[i]&gt;l)&#123;m--;i--;continue;&#125; &#125; if(spec&gt;=0)cout&lt;&lt;spec&lt;&lt;endl,exit(0); sort(a,a+m); d[0]=a[0]; if(d[0]&gt;90)d[0]=90; for(int i=1;i&lt;m;i++)&#123; d[i]=a[i]-a[i-1]; if(d[i]&gt;90)d[i]=90; &#125; int nd=0; for(int i=0;i&lt;m;i++)&#123; nd+=d[i]; stone[nd]++; &#125; l=nd; int ans=0x7fffffff; memset(f,0x3f,sizeof(f)); f[0]=0; for(int i=0;i&lt;=l+t;i++)&#123; for(int j=max(i-t, 0);j&lt;=i-s;j++)f[i]=min(f[i],f[j]); f[i]+=stone[i]; if(i&gt;=l)ans=min(ans,f[i]); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 篝火晚会[思维+模拟,中] 题面有锅 突然发现操作数不必要连续。 尝试构造。 我们假设从1开始。$a_1=1,a_n = a[l],\\quad a_2=a[2]$. 接着判断左右哪一个相同。 如果相同的话就填入，两个都不同的话就判断错误。 接着实现最小代价。 $\\mathcal O (n)$处理目标链，$\\mathcal O(n^2)$的时间复杂度 in total. 尝试优化 顺时针时，期望圈数组中第i个人，初始时应该在$b[i]$,所以距离为$(i-b[i])$,为了使距离都在$0 \\to n-1$之间，写为$(i-b[i]+n)\\%n$ 逆时针时，期望圈数组中第$i$个人，初始时应该在$（n-b[i]+1）$的位置【这里其实是让n作为初始圈第1个位置】同理，写为$（n-b[i]+1+n）\\%n$; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;using namespace std;int c[50010];int l[50010],r[50010];int dis1[50010],dis2[50010];int ans1[50010],ans2[50010];int n,ans;bool err;void deb()&#123; for(int i=1;i&lt;=n;i++) cout&lt;&lt;c[i]&lt;&lt;&quot; &quot;;&#125;void input()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;l[i]&gt;&gt;r[i]; &#125; &#125;void build()&#123;// c[1]=1;// c[n]=l[1];// c[2]=r[1];// for (int i=3; i&lt;n; i++)// if (l[c[i-1]]==c[i-2]) c[i]=r[c[i-1]];// else c[i]=l[c[i-1]]; c[1] = 1, c[n] = l[1] , c[2] = r[1]; for(int i=2;i&lt;=n-1;i++)&#123; if(l[c[i]]==c[i-1]) c[i+1] = r[c[i]]; else if(r[c[i]]==c[i-1]) c[i+1] = l[c[i]]; else&#123; err = 1; return; &#125; &#125;&#125;void solve()&#123; for(int i=1;i&lt;=n;i++)&#123; ans1[(c[i]-i+n)%n]++; ans2[(c[i]+i-1)%n]++; &#125; for (int i=0;i&lt;n;++i)&#123; if (ans&lt;ans1[i]) ans=ans1[i]; if (ans&lt;ans2[i]) ans=ans2[i]; &#125; cout&lt;&lt;n-ans&lt;&lt;endl;&#125;int main()&#123; input(); build(); if(err==1)&#123; cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; &#125;else&#123; solve(); &#125;&#125; 等价表达式[模拟,中] 过于生草！ 第一思路用表达式树进行求解。 考虑一下如何用后缀表达式树进行书写。 核心思路是求值。 若取出的字符是数字，则分析出完整数字，该操作数直接送入数字栈。 若取出的字符是运算符，则将该运算符与符号栈栈顶元素比较，如果该运算符优先级(不包括括号运算符)大于该栈顶运算符优先级，则将该运算符进该栈；否则，将该栈的栈顶运算符弹出，并将数字栈中的最后两个数字进行计算，直至符号栈栈顶运算符小于该运算符优先级，最后将该运算符送入符号栈。 若取出的字符是“((”，则直接送入符号栈顶。 若取出的字符是“))”，则将距离符号栈栈顶最近的“((”之间的运算符，逐个出栈，并依次取出数字栈中的数字进行计算，最后抛弃“))”。 重复上面的1~4.步，直至处理完所有的输入字符。 看上去很显然。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;int level[200];const int mod=1e9+7, x = 131;stack&lt;int&gt;num;stack&lt;char&gt;opera;string s;string read()&#123; string ss; char ch = getchar(); while(ch==&#x27;\\n&#x27;||ch==&#x27;\\r&#x27;||ch==&#x27; &#x27;) ch=getchar(); while(ch!=&#x27;\\n&#x27;&amp;&amp;ch!=&#x27;\\r&#x27;)&#123; if(ch!=&#x27; &#x27;) ss+=ch; ch=getchar(); if(ch==EOF) break; &#125; return ss;&#125;int quickPower(int n1,int n2)&#123; ull ans = 1,pow = n1; while(n2)&#123; if(n2&amp;1) ans = ans*pow%mod; pow = pow*pow%mod; n2&gt;&gt;=1; &#125; return ans%mod;&#125;void calculate()&#123; int n1 = num.top(); num.pop(); int n2 = num.top(); num.pop(); int ans; switch (opera.top()) &#123; case &#x27;+&#x27;:ans = (n2+n1)%mod; break; case &#x27;-&#x27;:ans = (n2-n1+mod)%mod; break; case &#x27;*&#x27;:ans = ( (long long)(n2%mod) * (n1%mod) )%mod; break; case &#x27;^&#x27;:ans = quickPower(n2,n1); &#125; num.push(ans); opera.pop();&#125;void pushStack()&#123; int len = (int)s.length(),sum = 0; for(int i = 0;i &lt; len;i++)&#123; if(s[i] == &#x27;a&#x27;) num.push(x); else if(isdigit(s[i]))&#123; sum = sum*10+(s[i]-&#x27;0&#x27;); if(i == len-1||!isdigit(s[i+1]) ) num.push(sum),sum = 0; &#125; else &#123; if(s[i] == &#x27;(&#x27;) &#123; opera.push(&#x27;(&#x27;); continue; &#125;else if(s[i] == &#x27;)&#x27;)&#123; while(!opera.empty() &amp;&amp; opera.top() != &#x27;(&#x27;) calculate(); if(!opera.empty() &amp;&amp; opera.top() == &#x27;(&#x27;) opera.pop(); continue; &#125; while(!opera.empty() &amp;&amp; level[s[i]] &lt;= level[opera.top()]) calculate(); opera.push(s[i]); &#125; &#125;&#125;int getResult()&#123; pushStack(); while(!opera.empty())&#123; if(opera.top()==&#x27;(&#x27;) &#123; opera.pop();continue; &#125; calculate(); &#125; return num.top();&#125;int main()&#123; freopen(&quot;D:\\\\in.txt&quot;,&quot;r&quot;,stdin); level[&#x27;^&#x27;] = 4;level[&#x27;*&#x27;] = 3;level[&#x27;+&#x27;] = 2;level[&#x27;-&#x27;] = 2; s = read(); int n,ans; ans = getResult(); cin&gt;&gt;n; for(int i = 0;i &lt; n;i++)&#123; while(!num.empty()) num.pop(); while(!opera.empty()) opera.pop(); s = read(); if(getResult() == ans) printf(&quot;%c&quot;,&#x27;A&#x27;+i); &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;#define d cout&lt;&lt;__LINE__&lt;&lt;&quot; &quot;&lt;&lt;__FUNCTION__&lt;&lt;endl;#define ll long longusing namespace std;const int mod = 1e9+9;int ans[29];stack&lt;int &gt; num;stack&lt;char &gt; op;string s=&quot;(a-1)^2+4*a&quot;;string read()&#123; string ss; char ch = getchar(); while(ch==&#x27;\\n&#x27;||ch==&#x27;\\r&#x27;||ch==&#x27; &#x27;) ch=getchar(); while(ch!=&#x27;\\n&#x27;&amp;&amp;ch!=&#x27;\\r&#x27;)&#123; if(ch!=&#x27; &#x27;) ss+=ch; ch=getchar(); if(ch==EOF) break; &#125; return ss;&#125;int qpow(int a,int b,int mod)&#123; int tmp=1; while(b&gt;0)&#123; if(b&amp;1) tmp = tmp*a%mod; b&gt;&gt;=1; a = a*a % mod; &#125; return tmp;&#125;void calc()&#123; int num1 = num.top();num.pop(); int num2 = num.top();num.pop(); char oper = op.top(); if(oper==&#x27;+&#x27;)&#123; int ans = (num1+num2)%mod; num.push(ans); &#125;else if(oper==&#x27;-&#x27;)&#123; num.push((num2-num1+mod)%mod); &#125;else if(oper==&#x27;*&#x27;)&#123; num.push((ll)num1*(ll)num2%mod); &#125;else if(oper==&#x27;^&#x27;)&#123; num.push(qpow(num2,num1,1e9+9)); &#125; op.pop();&#125;int gettp(char c)&#123; if(c==&#x27;+&#x27; || c==&#x27;-&#x27;) return 2; else if(c==&#x27;*&#x27;) return 3; else if(c==&#x27;^&#x27;) return 4; else return 0;&#125;void build()&#123; int sum = 0; int l = (int)s.size(); for (int i=0;i&lt;l;i++)&#123; if(s[i]==&#x27; &#x27;) continue; if(s[i] == &#x27;a&#x27;) num.push(131); else if(isdigit(s[i]))&#123; sum*=10; sum+=s[i]-&#x27;0&#x27;; if(i==l-1 || !isdigit(s[i+1]))num.push(sum),sum=0; &#125;else&#123; if(s[i]==&#x27;(&#x27;)&#123; op.push(&#x27;(&#x27;); continue; &#125;else if(s[i]==&#x27;)&#x27;)&#123; while(!op.empty() &amp;&amp; op.top()!=&#x27;(&#x27;) calc(); if(!op.empty()&amp;&amp; op.top()==&#x27;(&#x27;) op.pop(); continue; &#125; while(!op.empty() &amp;&amp; gettp(s[i])&lt;=gettp(op.top())) calc(); op.push(s[i]); &#125; &#125;&#125;int make()&#123; build(); while(!op.empty())&#123; if(op.top()==&#x27;(&#x27;)&#123; op.pop();continue; &#125; calc(); &#125; return num.top();&#125;int main()&#123; freopen(&quot;D:\\\\in.txt&quot;,&quot;r&quot;,stdin); s = read(); int n,ans; ans = make(); cin&gt;&gt;n; for(int i = 0;i &lt; n;i++)&#123; while(!num.empty()) num.pop(); while(!op.empty()) op.pop(); s = read(); int asn = make(); cout&lt;&lt;asn&lt;&lt;endl; if(asn == ans) printf(&quot;%c&quot;,&#x27;A&#x27;+i); &#125; return 0;&#125; $2^k$进制数[组合数学,易] 觉得这是个毒瘤的组合数学题 没想到这就是个高中数学题。 分类讨论： 考虑一个弱化版本的问题，使得$w|d$，并且最高位不是0，并且$\\large\\frac{k}{w}=d$显然得到： 共有$\\large C_{2^{k-1}}^d$个情况。 加上0的情况，显然有：$\\displaystyle \\Large \\sum_{i=2}^{d}\\large C_{2^{k-1}}^d$.(注意：由于有前导零，本质上不算严格递增或者递减。) 那么考虑如果$w \\nmid d$的时候，假设$\\large \\frac{k}{w}=d$, $\\large k-\\lfloor\\frac{k}{w}\\rfloor=m$. 对于首位不为0有$\\Large\\displaystyle \\sum_{i=1}^{2^m-1}C_{2^{k-1-i}}^{d}$. 对于首位为0的情况，转化为弱化版本，即为：$\\displaystyle \\Large \\sum_{i=2}^{d}\\large C_{2^{k-1}}^d$ 由于分步相加，设最终方案数为$f(n)$,显然可以得到: f(n) = \\begin{align} \\Large\\displaystyle \\sum_{i=1}^{2^m-1}C_{2^{k-1-i}}^{d}+\\displaystyle \\Large \\sum_{i=2}^{d}\\large C_{2^{k-1}}^d \\end{align}其中， \\begin{aligned} m &= k-\\lfloor\\frac{n}{k}\\rfloor \\qquad \\large(也就是n\\bmod{k}) \\\\ d &= \\frac{n}{k} \\end{aligned}高精度计算即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;string c[250][250];int n,k;int p,t;int res;void deb(int a[],int n)&#123; for(int i=0;i&lt;=n;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;&quot;\\n&quot;;&#125;int aa[10020],bb[10020],cc[10020];string sum(string a,string b)&#123; memset(aa,0,sizeof(aa)); memset(bb,0,sizeof(bb)); memset(cc,0,sizeof(cc)); int lena=a.size(); int lenb=b.size(); for(int i=0;i&lt;lena;i++) aa[i+1]=a[lena-i-1]-48; for(int i=0;i&lt;lenb;i++) bb[i+1]=b[lenb-i-1]-48; int p=1; for(p=1;p&lt;=max(lena,lenb)||cc[p];p++)&#123; cc[p]+=aa[p]+bb[p]; cc[p+1]+=cc[p]/10; cc[p]%=10; &#125; string C=&quot;\\0&quot;; for(int i=p-1;i;i--) C+=char(cc[i]+48); return C;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;k,&amp;n); p=n/k; res=n%k; t=(1&lt;&lt;k); c[0][0]=&quot;1&quot;; for(int i=1;i&lt;=t-1;i++) c[i][0]=c[i][i]=&quot;1&quot;; for(int i=1;i&lt;t;i++) for(int j=1;j&lt;i;j++) c[i][j]=sum(c[i-1][j-1],c[i-1][j]); string ans=&quot;0&quot;; for( int i=2;i&lt;=p;i++)&#123; if(i&gt;t-1) break; ans=sum(ans,c[t-1][i]); &#125; int pp=(1&lt;&lt;res)-1; for(int i=1;i&lt;=pp;i++)&#123; if(p&gt;t-1-i) break; ans=sum(ans,c[t-1-i][p]); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 靶形数独[搜索,难] 采取(启发式)生成-验证的方法。 先搜索列数含有0少的。 然后挨个尝试。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct f&#123; int rank,sum;&#125;cou[10];int a[10][10],h[10][10],l[10][10],g[10][10],s[100][4],,ok,most=-1,have;bool cmp(f a,f b)&#123; return a.sum&lt;b.sum; &#125;void dfs(int p,int score)&#123; if(p==u)&#123; if(score&gt;most) most=score; return; &#125; for(int i=1;i&lt;=9;i++)&#123; if(!h[s[p][0]][i]&amp;&amp;!l[s[p][1]][i]&amp;&amp;!g[s[p][3]][i])&#123; h[s[p][0]][i]=l[s[p][1]][i]=g[s[p][3]][i]=1; dfs(p+1,score+(s[p][2]*i)); h[s[p][0]][i]=l[s[p][1]][i]=g[s[p][3]][i]=0; &#125; &#125; return;&#125;int which(int i,int j)&#123; if(i&lt;=3)&#123; if(j&lt;=3)return 1; else if(j&lt;=6)return 2; else return 3; &#125;else if(i&lt;=6)&#123; if(j&lt;=3)return 4; else if(j&lt;=6)return 5; else return 6; &#125;else&#123; if(j&lt;=3)return 7; else if(j&lt;=6)return 8; else return 9; &#125;&#125;int point(int i,int j)&#123; if(i==1||j==1||i==9||j==9)return 6; if(i==2||j==2||i==8||j==8)return 7; if(i==3||j==3||i==7||j==7)return 8; if(i==4||j==4||i==6||j==6)return 9; return 10;&#125;int main()&#123; for(int i=1;i&lt;=9;i++) cou[i].rank=i; for(int i=1;i&lt;=9;i++) for(int j=1;j&lt;=9;j++)&#123; cin&gt;&gt;a[i][j]; if(a[i][j]&gt;0) h[i][a[i][j]]=l[j][a[i][j]]=g[which(i,j)][a[i][j]]=1,have+=a[i][j]*point(i,j); else cou[i].sum++; &#125; sort(cou+1,cou+10,cmp); for(int i=1;i&lt;=9;i++)&#123; for(int j=1;j&lt;=9;j++) if(a[cou[i].rank][j]==0) s[u][0]=cou[i].rank,s[u][1]=j,s[u][2]=point(cou[i].rank,j),s[u++][3]=which(cou[i].rank,j); &#125; dfs(0,have); cout&lt;&lt;most&lt;&lt;endl; return 0;&#125; 开车旅行[倍增,难] 不妨先打一个暴力得分。 如下所示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define ll long long#define N 100010using namespace std;ll c1[N], c2[N], n, m, h[N] = &#123; INT_MAX &#125;, dist1[N], dist2[N];double minv = INT_MAX;int main()&#123; cin&gt;&gt;n; for (int i = 1; i &lt;= n; ++i)cin&gt;&gt;h[i]; for (int i = n - 1; i &gt;= 1; --i)&#123; register ll minn = i + 1, minn2 = 0; dist1[i] = abs(h[i] - h[i + 1]); for (int j = i + 2; j &lt;= n; ++j)&#123; if (dist1[i] &gt; abs(h[i] - h[j]) || (dist1[i] == abs(h[i] - h[j]) &amp;&amp; h[j] &lt; h[minn]))&#123; dist2[i] = dist1[i]; dist1[i] = abs(h[i] - h[j]); minn2 = minn; minn = j; &#125;else if (dist2[i] == 0 || dist2[i] &gt; abs(h[i] - h[j]) || (dist2[i] == abs(h[i] - h[j]) &amp;&amp; h[j] &lt; h[minn2]))&#123; dist2[i] = abs(h[i] - h[j]); minn2 = j; &#125; &#125; c1[i] = minn; c2[i] = minn2; &#125; ll x0; cin&gt;&gt;x0;ll ans = 0; for (int i = 1; i &lt;= n; ++i)&#123; ll a = 0, b = 0, loc = i, turn = 0; while (1)&#123; if (turn)&#123; if (a + b + dist1[loc] &gt; x0 || !c1[loc])break; b += dist1[loc]; loc = c1[loc]; &#125;else&#123; if (a + b + dist2[loc] &gt; x0 || !c2[loc])break; a += dist2[loc]; loc = c2[loc]; &#125; turn ^= 1; &#125; if (!ans || 1.0*a / b - minv &lt; -0.00000001 || (fabs(1.0*a / b - minv) &lt;= 0.00000001&amp;&amp;h[ans] &lt; h[i]))&#123; minv = 1.0*a / b; ans = i; &#125; &#125; printf(&quot;%lld\\n&quot;, ans); cin&gt;&gt;m; while (m--)&#123; ll s , x , a = 0, b = 0, turn = 0; cin&gt;&gt;s&gt;&gt;x; while (1)&#123; if (turn)&#123; if (a + b + dist1[s] &gt; x || !c1[s])break; b += dist1[s]; s = c1[s]; &#125; else&#123; if (a + b + dist2[s] &gt; x || !c2[s])break; a += dist2[s]; s = c2[s]; &#125; turn ^= 1; &#125; printf(&quot;%lld %lld\\n&quot;, a, b); &#125; return 0;&#125; 70pts(TLE了许多) 关于正解： 对于每一个点$i$，$a$的选择是唯一的，$b$的选择也是唯一的，所以不存在最优解 到达的点也是固定的。并且他们只会去比他们要大的点。于是对于终点只会有三种情况 到了n点，接下来是A开车，旅程结束。 到了n点，接下来是B开车，旅程结束。 到了n-1点，接下来是A开车，旅程结束。 倍增即可。 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; using namespace std; int n, m, l, r, j; struct node&#123; int i, v, l, r; bool operator &lt; (const node &amp; A) const&#123; return v &lt; A.v; &#125; &#125;d[100005]; int h[100005], p[100005]; int stA[100005][21], stB[100005][21], f[100005][21]; int na[100005], nb[100005], a, b, ans = n; double minn = 2147483647; bool zuo()&#123; if(!l) return 0; if(!r) return 1; return d[j].v-d[l].v&lt;=d[r].v-d[j].v; &#125; int pd(int a, int b)&#123; if(!a) return d[b].i; if(!b) return d[a].i; if(d[j].v-d[a].v &lt;= d[b].v-d[j].v) return d[a].i; return d[b].i; &#125; void make_st()&#123; int i, j; for(j = 1; j &lt;= 19; j++)&#123; for(i = 1; i &lt;= n; i++)&#123; f[i][j] = f[f[i][j-1]][j-1]; stA[i][j] = stA[i][j-1] + stA[f[i][j-1]][j-1]; stB[i][j] = stB[i][j-1] + stB[f[i][j-1]][j-1]; &#125; &#125; &#125; void getab(long long x, int p)&#123; int i, j; a = b = 0; for(i = 19; i &gt;= 0; i--)&#123; if(f[p][i] &amp;&amp; (long long)(a + b + stA[p][i]+stB[p][i]) &lt;= x)&#123; a += stA[p][i]; b += stB[p][i]; p = f[p][i]; &#125; &#125; if(na[p] &amp;&amp; a + b + stA[p][0] &lt;= x) a += stA[p][0]; &#125; int main()&#123; int i; long long x; scanf(&quot;%d&quot;, &amp;n); for(i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;d[i].v); for(i = 1; i &lt;= n; i++) d[i].i = i; sort(d+1, d+i); for(i = 1; i &lt;= n; i++) p[d[i].i] = i; for(i = 1; i &lt;= n; i++) d[i].l = i-1, d[i].r = i+1; d[1].l = d[n].r = 0; for(i = 1; i &lt;= n; i++)&#123; j = p[i]; l = d[j].l; r = d[j].r; if(zuo()) nb[i] = d[l].i, na[i] = pd(d[l].l, r); else nb[i] = d[r].i, na[i] = pd(l, d[r].r); if(l) d[l].r = r; if(r) d[r].l = l; &#125; for(i = 1; i &lt;= n; i++)&#123; f[i][0] = nb[na[i]]; stA[i][0] = abs(d[p[i]].v - d[p[na[i]]].v); stB[i][0] = abs(d[p[f[i][0]]].v - d[p[na[i]]].v); &#125; make_st(); scanf(&quot;%lld%d&quot;, &amp;x, &amp;m); for(i = 1; i &lt;= n; i++)&#123; getab(x, i); if(b &amp;&amp; 1.0*a/b &lt; minn)&#123; minn = 1.0*a/b; ans = i; &#125; &#125; printf(&quot;%d\\n&quot;, ans); for(i = 1; i &lt;= m; i++)&#123; scanf(&quot;%d%lld&quot;, &amp;j, &amp;x); getab(x, j); printf(&quot;%d %d\\n&quot;, a, b); &#125; return 0; &#125; 借教室[线段树,中] 可以轻松地写一个暴力。 然而AC不来。 每张订单其实就可以看作是一个区间（操作），左右区间分别为开始时间和结束时间 这是一个区间操作 首选线段树？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;#define mid ((l+r)&gt;&gt;1)#define lson rt&lt;&lt;1,l,mid#define rson rt&lt;&lt;1|1,mid+1,rinline void read(int &amp;x)&#123; char c=getchar(); int p=1; x=0; while(!isdigit(c))&#123; if(c==&#x27;-&#x27;)p=-1; c=getchar(); &#125; while(isdigit(c))&#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^&#x27;0&#x27;); c=getchar(); &#125; x*=p;&#125;const int maxn=1000005;int minn[maxn&lt;&lt;2],tag[maxn&lt;&lt;2],n,m;inline int _min(int a,int b)&#123; return a&gt;b?b:a;&#125;inline void push_up(int rt)&#123; minn[rt]=_min(minn[rt&lt;&lt;1],minn[rt&lt;&lt;1|1]);&#125;inline void build(int rt,int l,int r)&#123; if(l==r)read(minn[rt]); else&#123; build(lson); build(rson); push_up(rt); &#125;&#125;inline void push_down(int rt)&#123; minn[rt&lt;&lt;1]-=tag[rt]; minn[rt&lt;&lt;1|1]-=tag[rt]; tag[rt&lt;&lt;1]+=tag[rt]; tag[rt&lt;&lt;1|1]+=tag[rt]; tag[rt]=0;&#125;inline void update(int rt,int l,int r,int L,int R,int num)&#123; if(l&gt;=L&amp;&amp;r&lt;=R)&#123; minn[rt]-=num; tag[rt]+=num; &#125; else&#123; if(tag[rt])push_down(rt); if(L&lt;=mid)update(lson,L,R,num); if(R&gt;mid)update(rson,L,R,num); push_up(rt); &#125;&#125;int main()&#123; read(n);read(m); build(1,1,n); for(register int i=1;i&lt;=m;++i)&#123; int d,s,j; read(d);read(s);read(j); update(1,1,n,s,j,d); if(minn[1]&lt;0)&#123; printf(&quot;-1\\n%d\\n&quot;,i); return 0; &#125; &#125; puts(&quot;0&quot;); return 0;&#125; 控制疫情[二分,难] 考虑输出$-1$的情况：当1号点的出边个数小于军队个数的时候。 其他情况： 考虑让其他人尽可能的往上走。调到距离根-1的时候结束。 特别的，如果有一段有一个没有，考虑先跳到首都完后到目标点。 思路评价 应当最小化最大值。 应当考虑二分。 如何写$\\text{check}$? 正解 我们会发现，离根节点越近的节点，控制的节点更多。所以由贪心的思想，所有的军队都要尽可能地往根节点走。 军队可以同时移动，说明我们要控制传染病的时间是军队移动到位时，移动时间最长的军队的移动时间。而我们要求最小值，即要求最大化最小值。 使用倍增的方法将军队在二分出的答案限制内尽力往上”提“，不过不可以到根节点。 如果当前军队可以到达根节点，那么记录一下它的编号和它到达根节点后还可以走的时间rest。如果这个军队i在根节点的子树x中，那么记录一下子树x的符合这个条件的点中，到根节点后剩余路程最短的点。如果不可以到达，记录它被”提“到的节点被军队设置了检查点。 如果一个节点建立了检查点或者它的所有子树都设立了检查点，则说明以这个节点为根的子树已经被“封死”。记录根节点的所有子树中，未被“封死”的子树。 将我们已经记录好了的可以到根节点的军队按照剩余路程从大到小排序。 将未被“封死”的子树按照到子树到根节点的距离从大到小排序。 然后依次处理未被“封死”的子树要由哪支军队来管辖。 当然离根节点远的军队由剩余路程大的军队来管辖是吼滴啦，不过缀吼滴还是就由本来就在这棵子树上的军队来管辖。所以我们先查看我们事先记录的(在子树x中，可以到达根节点，且到根节点后剩余路程最小的军队)是否被使用，如果被使用，再看当前没有被使用的军队里剩余路程最大的可否到达这棵子树。 这样我们就可以判断当前二分出的答案是否可行了。 代码方案 预处理倍增 如果当前节点有到达根节点的 石立 实力，那么记录编号和还剩下的时间t. 然后检查是不是有没有被封锁的subtree. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N=6e4;int n,m,t,tot=0,atot=0,btot=0,ctot=0;int d[N],query[N],f[N][20];int ver[2*N],edge[2*N],Next[2*N],head[N];bool ok,sta[N],need[N];ll ans,tim[N],ned[N],dist[N][20];pair&lt;ll,int&gt; h[N];queue&lt;int&gt; q;void add(int x,int y,int z)&#123; ver[++tot]=y,edge[tot]=z,Next[tot]=head[x],head[x]=tot;&#125;void bfs()&#123; q.push(1); d[1]=1; while(q.size())&#123; int x=q.front();q.pop(); for(int i=head[x];i;i=Next[i])&#123; int y=ver[i]; if(d[y])continue; d[y]=d[x]+1; f[y][0]=x,dist[y][0]=edge[i]; for(int j=1;j&lt;=t;j++)&#123; f[y][j]=f[f[y][j-1]][j-1]; dist[y][j]=dist[y][j-1]+dist[f[y][j-1]][j-1]; &#125; q.push(y); &#125; &#125;&#125;bool dfs(int x)&#123; bool pson=0; if(sta[x]) return 1; for(int i=head[x];i;i=Next[i])&#123; int y=ver[i]; if(d[y]&lt;d[x])continue; pson=1; if(!dfs(y))return 0; &#125; if(!pson) return 0; return 1;&#125;bool check(ll lim)&#123; memset(sta,0,sizeof(sta)); memset(tim,0,sizeof(tim)); memset(ned,0,sizeof(ned)); memset(h,0,sizeof(h)); memset(need,0,sizeof(need)); atot=0,btot=0,ctot=0; for(int i=1;i&lt;=m;i++)&#123; ll x=query[i],cnt=0; for(int j=t;j&gt;=0;j--) if(f[x][j]&gt;1 &amp;&amp; cnt+dist[x][j]&lt;=lim)&#123; cnt+=dist[x][j]; x=f[x][j]; &#125; if(f[x][0]==1 &amp;&amp; cnt+dist[x][0]&lt;=lim) h[++ctot]=make_pair(lim-cnt-dist[x][0],x); else sta[x]=1; &#125; for(int i=head[1];i;i=Next[i]) if(!dfs(ver[i])) need[ver[i]]=1; sort(h+1,h+ctot+1); for(int i=1;i&lt;=ctot;i++) if(need[h[i].second] &amp;&amp; h[i].first&lt;dist[h[i].second][0]) need[h[i].second]=0; elsetim[++atot]=h[i].first; for(int i=head[1];i;i=Next[i])if(need[ver[i]])ned[++btot]=dist[ver[i]][0]; if(atot&lt;btot)return 0; sort(tim+1,tim+atot+1),sort(ned+1,ned+btot+1); int i=1,j=1; while(i&lt;=btot &amp;&amp; j&lt;=atot) if(tim[j]&gt;=ned[i])i++,j++; elsej++; if(i&gt;btot)return 1; return 0;&#125;int main()&#123; ll l=0,r=0,mid; cin&gt;&gt;n; t=log2(n)+1; for(int i=1;i&lt;n;i++)&#123; int x,y,z; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z),add(y,x,z); r+=z; &#125; bfs(); cin&gt;&gt;m; for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;query[i]); while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(check(mid))&#123; r=mid-1; ans=mid; ok=1; &#125; else l=mid+1; &#125; if(!ok)cout&lt;&lt;-1; else cout&lt;&lt;ans; return 0;&#125; 虫食算[搜索/高斯消元,难] 大力搜索 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;cstdlib&gt;#include&lt;iomanip&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#define ll long long#define R register intstatic char B[1&lt;&lt;8],*S=B,*D=B;#define getchar() (S==D&amp;&amp;(D=(S=B)+fread(B,1,1&lt;&lt;8,stdin),S==D)?EOF:*S++)using namespace std;inline int g() &#123; R ret=0,fix=1; register char ch; while(!isdigit(ch=getchar())) fix=ch==&#x27;-&#x27;?-1:fix; do ret=ret*10+(ch^48); while(isdigit(ch=getchar())); return ret*fix;&#125;inline void gs(int* c) &#123; register char ch; while(!isalpha(ch=getchar())); do *++c=int(ch-&#x27;A&#x27;); while(isalpha(ch=getchar())); &#125; int n,rw[27],s[4][27],inc[27];bool vis[27];inline void dfs(int x) &#123; if(x==0) &#123;for(R i=0;i&lt;n;++i) printf(&quot;%d &quot;,rw[i]); exit(0);&#125; //print(); if(rw[s[1][x]]==-1) &#123; for(R i=n-1;i&gt;=0;--i) if(!vis[i]) &#123; rw[s[1][x]]=i,vis[i]=true; if(rw[s[2][x]]==-1) &#123; for(R j=0;j&lt;n;++j) if(!vis[j])&#123; rw[s[2][x]]=j,vis[j]=true; if(rw[s[3][x]]==-1) &#123; rw[s[3][x]]=(rw[s[1][x]]+rw[s[2][x]]+inc[x]); if(rw[s[3][x]]&gt;=n) rw[s[3][x]]%=n,inc[x-1]=1; if(vis[rw[s[3][x]]]) &#123;rw[s[3][x]]=-1; inc[x-1]=0; goto ed2;&#125; vis[rw[s[3][x]]]=true; dfs(x-1); inc[x-1]=0; vis[rw[s[3][x]]]=false; rw[s[3][x]]=-1; &#125; else &#123; if(rw[s[3][x]]==(rw[s[1][x]]+rw[s[2][x]]+inc[x])%n) inc[x-1]=(rw[s[1][x]]+rw[s[2][x]]+inc[x])/n,dfs(x-1),inc[x-1]=0; &#125; ed2: rw[s[2][x]]=-1,vis[j]=false; &#125; &#125; else &#123; if(rw[s[3][x]]==-1) &#123; rw[s[3][x]]=(rw[s[1][x]]+rw[s[2][x]]+inc[x]); if(rw[s[3][x]]&gt;=n) rw[s[3][x]]%=n,inc[x-1]=1; if(vis[rw[s[3][x]]]) &#123;rw[s[3][x]]=-1; inc[x-1]=0; goto enddd;&#125; vis[rw[s[3][x]]]=true; dfs(x-1); inc[x-1]=0; vis[rw[s[3][x]]]=false; rw[s[3][x]]=-1; &#125; else &#123; if(rw[s[3][x]]==(rw[s[1][x]]+rw[s[2][x]]+inc[x])%n) inc[x-1]=(rw[s[1][x]]+rw[s[2][x]]+inc[x])/n,dfs(x-1),inc[x-1]=0; else &#123;inc[x-1]=0; &#125; &#125; enddd:; &#125; rw[s[1][x]]=-1,vis[i]=false; &#125; &#125; else &#123; if(rw[s[2][x]]==-1) &#123; for(R j=n-1;j&gt;=0;--j) if(!vis[j]) &#123; rw[s[2][x]]=j,vis[j]=true; if(rw[s[3][x]]==-1) &#123; rw[s[3][x]]=(rw[s[1][x]]+rw[s[2][x]]+inc[x]); if(rw[s[3][x]]&gt;=n) rw[s[3][x]]%=n,inc[x-1]=1; if(vis[rw[s[3][x]]]) &#123;rw[s[3][x]]=-1; inc[x-1]=0; goto ed21;&#125; vis[rw[s[3][x]]]=true; dfs(x-1); inc[x-1]=0; vis[rw[s[3][x]]]=false; rw[s[3][x]]=-1; &#125; else &#123; if(rw[s[3][x]]==(rw[s[1][x]]+rw[s[2][x]]+inc[x])%n) inc[x-1]=(rw[s[1][x]]+rw[s[2][x]]+inc[x])/n,dfs(x-1),inc[x-1]=0; &#125; ed21: vis[j]=false; &#125; rw[s[2][x]]=-1; &#125; else &#123; if(rw[s[3][x]]==-1) &#123; rw[s[3][x]]=(rw[s[1][x]]+rw[s[2][x]]+inc[x]); if(rw[s[3][x]]&gt;=n) rw[s[3][x]]%=n,inc[x-1]=1; if(vis[rw[s[3][x]]]) &#123;rw[s[3][x]]=-1; inc[x-1]=0; goto end;&#125; vis[rw[s[3][x]]]=true; dfs(x-1); inc[x-1]=0; vis[rw[s[3][x]]]=false; rw[s[3][x]]=-1; &#125; else &#123; if(rw[s[3][x]]==(rw[s[1][x]]+rw[s[2][x]]+inc[x])%n) inc[x-1]=(rw[s[1][x]]+rw[s[2][x]]+inc[x])/n,dfs(x-1),inc[x-1]=0; &#125; end:; &#125; &#125;&#125;signed main() &#123; n=g(); for(R i=1;i&lt;=3;++i) gs(s[i]); memset(rw,0xff,sizeof(rw)); dfs(n);&#125; 高斯消元 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;int n,lcn,multi,multj;struct mat&#123; int c[30][30]; int l[30][30];&#125;ma;int num[30];void read()&#123; cin&gt;&gt;n; string s1,s2,s3; cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3; for(int i=1;i&lt;=n;i++)&#123; int pos=n-i; int c1=s1[pos]-&#x27;A&#x27;+1;ma.c[i][c1]++; int c2=s2[pos]-&#x27;A&#x27;+1;ma.c[i][c2]++; int c3=s3[pos]-&#x27;A&#x27;+1;ma.c[i][c3]--; ma.l[i][i]=1; &#125; &#125;int gcd(int a,int b)&#123; if(b==0) return a; return gcd(b,a%b);&#125;void gauss()&#123; for(int i=1;i&lt;=n;i++)&#123; int vec=i; for(int j=i+1;j&lt;=n;j++) &#123; if(abs(ma.c[vec][i])&lt;abs(ma.c[j][i])) vec=j; &#125; if(vec!=i)&#123; for(int j=1;j&lt;=n;j++) &#123;swap(ma.c[i][j],ma.c[vec][j]);swap(ma.l[i][j],ma.l[vec][j]);&#125; &#125; for(int j=1;j&lt;=n;j++)&#123; if(ma.c[j][i]!=0&amp;&amp;j!=i)&#123; lcn=ma.c[j][i]*ma.c[i][i]/gcd(ma.c[i][i],ma.c[j][i]); multi=lcn/ma.c[i][i]; multj=lcn/ma.c[j][i]; for(int k=1;k&lt;=n;k++)&#123; ma.c[j][k]=ma.c[j][k]*multj-ma.c[i][k]*multi; ma.l[j][k]=ma.l[j][k]*multj-ma.l[i][k]*multi; &#125; &#125; &#125; &#125;&#125;void judge()&#123; bool flag=true; int z[30]; int m[30]; for(int i=0;i&lt;=n;i++) m[i]=0; for(int i=1;i&lt;=n;i++)&#123; z[i]=0; for(int j=1;j&lt;=n;j++) z[i]+=ma.l[i][j]*num[j]; if(z[i]%ma.c[i][i]!=0) return; else z[i]/=ma.c[i][i]; if(z[i]&lt;0||z[i]&gt;=n||m[z[i]]==1)&#123;flag=false;break;&#125; m[z[i]]=1; &#125; if(flag==true)&#123; for(int i=1;i&lt;=n;i++) cout&lt;&lt;z[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; exit(0); &#125;&#125;void dfs(int pos,int value)&#123; num[pos]=value; if(pos==n)&#123; judge(); return; &#125; dfs(pos+1,0); num[pos]=value+n; dfs(pos+1,-1);&#125;int main()&#123; read(); gauss(); dfs(1,0); return 0;&#125; 树网的核(DP+树相关,难) 先找到树的一个直径。 计算直径每一个点到大的最远距离 枚举直径，进行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define MAXN 10010using namespace std;struct Edge&#123; int to,nxt,w;&#125;e[MAXN];int head[MAXN],cnt;void add(int u,int v,int w)&#123; e[++cnt].to = v; e[cnt].nxt = head[u]; e[cnt].w = w; head[u] = cnt;&#125;int n,s,A,B,dis[MAXN],dis2[MAXN],fa[MAXN];bool vis[MAXN];void dfs(int i,int F,int dist ,int &amp;R)&#123; if(dist&gt;dis[R])&#123; R=i; &#125; dis[i] = dist,fa[i] = F; for(int q = head[i];q;q = e[q].nxt)&#123; int j = e[q].to; if(j==F) continue; dfs(j,i,dist+e[q].w,R); &#125;&#125;void dfs2(int i,int dist,int rt)&#123; vis[i] = true; dis2[rt] = max(dis2[rt],dist); for(int q = head[i];q;q = e[q].nxt)&#123; int j = e[q].to; if(!vis[j]) dfs2(j,dist+e[q].w,rt); &#125;&#125;void build()&#123; int u,v,l; cin&gt;&gt;n&gt;&gt;s; for(int i=1;i&lt;n;i++)&#123; cin&gt;&gt;u&gt;&gt;v&gt;&gt;l; add(u,v,l); add(v,u,l); &#125; dfs(1,0,0,A=0); dfs(A,0,0,B=0); for(int i=B;i;i = fa[i]) vis[i] = 1; for(int i=B;i;i=fa[i]) dfs2(i,0,i);&#125;int ans = 0x7f;void solve()&#123; for(int i=B;i;i = fa[i])&#123; for(int j = i;j;j = fa[j])&#123; if(dis[i]-dis[j]&lt;=s)&#123; int T = max(dis[j],dis[B]-dis[i]); for(int k=i;;k = fa[k])&#123; T = max(T,dis2[k]); if(k==j) break; &#125; ans = min(ans,T); &#125;else break; &#125; &#125; printf(&quot;%d\\n&quot;,n==1?0:ans);&#125;int main()&#123; build(); solve(); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=305;struct edge&#123; int to,l,next;&#125;e[maxn*2];int first[maxn],np;void add(int u,int v,int l)&#123; e[++np]=(edge)&#123;v,l,first[u]&#125;; first[u]=np;&#125;int n,s,A,B,dis[maxn],dis2[maxn],fa[maxn];bool vis[maxn];void dfs(int i,int F,int dist,int&amp; R)&#123; if(dist&gt;dis[R]) R=i; dis[i]=dist,fa[i]=F; for(int p=first[i];p;p=e[p].next)&#123; int j=e[p].to; if(j==F) continue; dfs(j,i,dist+e[p].l,R); &#125;&#125;void dfs2(int i,int dist,int rt)&#123; vis[i]=true; dis2[rt]=max(dis2[rt],dist); for(int p=first[i];p;p=e[p].next)&#123; int j=e[p].to; if(!vis[j]) dfs2(j,dist+e[p].l,rt); &#125;&#125;void build()&#123; int u,v,l; scanf(&quot;%d%d&quot;,&amp;n,&amp;s); for(int i=1;i&lt;n;i++)&#123; scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;l); add(u,v,l),add(v,u,l); &#125; dfs(1,0,0,A=0); dfs(A,0,0,B=0); for(int i=B;i;i=fa[i]) vis[i]=true; for(int i=B;i;i=fa[i]) dfs2(i,0,i);&#125;int ans=0xffffff; void solve()&#123; for(int i=B;i;i=fa[i]) for(int j=i;j;j=fa[j]) if(dis[i]-dis[j]&lt;=s)&#123; int T=max(dis[j],dis[B]-dis[i]); for(int k=i;;k=fa[k])&#123; T=max(T,dis2[k]); if(k==j) break; &#125; ans=min(ans,T); &#125; else break; printf(&quot;%d\\n&quot;,n==1?0:ans);&#125;int main()&#123; build(); solve(); return 0;&#125; 双栈排序(二分图,中) 二分图 G=(V, E)，其中G代表图，V代表这个图的所有顶点的集合，E代表这个图所有连线的集合。现如今如果能将V这个顶点集分成两个互不相交的子集A、B，E这个边集内所有边的两个顶点分别属于A、B两个子集的话，我们就称这个图为二分图。 eg. 二分图染色 开数组保存。 建立二维数组，每个数组$e[i][j]$表示i到j有边。 相邻颜色相同或者同一个点不同颜色的情况，说明不是二分图。 题目思路 对数字串进行两个两个逐次遍历，如果符合规则的便将二者连接起来，则当遍历结束后完成构图。 然后通过dfs染色，确立真正的二分图。然后借助染色表(记录每个元素颜色的数组)，进行相应的push(), pop()操作，最终便能完成排序。具体规则如下： 对于任意两个数t[i]和t[j],它们不能压入同一个栈中的充要条件: 存在一个k,使得i&lt;j&lt;k且t[k]&lt;t[i]&lt;t[j]。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define maxn 1004using namespace std;const int inf=19260817;int n,num;int color[maxn];int t[maxn];int s[maxn];bool flag,e[maxn][maxn];void paint(int x,int c)&#123; color[x]=c; for(int i=1;i&lt;=n;i++)&#123; if(e[x][i])&#123; if(color[i]==c) flag=false; if(!color[i]) paint(i,3-c); &#125; &#125;&#125;void make()&#123; s[n+1]=inf; for(int i=n;i&gt;=1;i--)&#123; s[i]=t[i]; if(s[i+1]&lt;s[i]) s[i]=s[i+1]; &#125; for(int i=1;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if(t[i]&lt;t[j] &amp;&amp; s[j+1]&lt;t[i])&#123; e[i][j]=e[j][i]=1; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!color[i])&#123; paint(i,1); &#125; &#125;&#125;void work()&#123; if(flag==false)&#123; printf(&quot;0\\n&quot;); return ; &#125; stack&lt;int&gt; stack1,stack2; int now=1; for(int i=1;i&lt;=n;i++)&#123; if(color[i]==1)&#123; stack1.push(t[i]); printf(&quot;a &quot;); &#125; else &#123; stack2.push(t[i]); printf(&quot;c &quot;); &#125; while((!stack1.empty() &amp;&amp; stack1.top()==now) || (!stack2.empty() &amp;&amp; stack2.top()==now))&#123; if(!stack1.empty() &amp;&amp; stack1.top()==now)&#123; stack1.pop(); now++; printf(&quot;b &quot;); &#125; else&#123; stack2.pop(); now++; printf(&quot;d &quot;); &#125; &#125; &#125;&#125;int main()&#123; flag=1; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;t[i]); &#125; make(); work(); return 0;&#125; 选择客栈[DP,中] 想到通过枚举完成。 如果是暴力枚举客栈的话，不能同时枚举两个客栈，那样会超时，所以只能同时枚举一个。我们枚举第二个客栈，然后用第二个客栈反推出前面的方案数。 思路就是，从1到n枚举，输入color和price的值，我们需要记录一个距离第二个客栈最近的咖啡厅价钱合理的客栈位置，用一个now变量记录。 开三个辅助数组，last[i]表示最后一个以i为颜色的客栈的位置，cnt[i]表示以i为颜色的客栈总数，sum[i]可以看作是一个临时数组，用来存储当前的方案数。 当前枚举到一个客栈i，这个i是第二个客栈，那么显然第一个客栈一定在第二个客栈之前，编号必定是0~i-1之间的一个数。如果我发现枚举的时候在某一个客栈前面有一个价钱合理的咖啡厅，那么在这之前的任何一个同色客栈都是第一个客栈可以选的，那么统计一下数量，这就是当前的方案数。 然后更新last数组，更新ans，让cnt[color]++，这样从左到右地推过来就好了。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int n,k,p;int a[500010];int b[500010];int now;int last[500010],sum[500010],cnt[500010],ans;int main()&#123; cin&gt;&gt;n&gt;&gt;k&gt;&gt;p; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]&gt;&gt;b[i]; if(b[i]&lt;=p) now = i; if(now&gt;=last[a[i]]) sum[a[i]] = cnt[a[i]]; last[a[i]] = i; ans+= sum[a[i]]; cnt[a[i]]++; &#125; cout&lt;&lt;ans;&#125; 计算系数(数论,简单) 答案： \\Large C_{p}^{m} =a^{m}b^{1-m} 123456789101112#include&lt;iostream&gt;using namespace std;long long x[1010][1010];int main()&#123; long long a,b,k,n,m; cin&gt;&gt;a&gt;&gt;b&gt;&gt;k&gt;&gt;n&gt;&gt;m; x[1][1]=1; for(int i=2;i&lt;=k+1;i++) for(int j=1;j&lt;=i;j++) x[i][j]=(x[i-1][j-1]*b+x[i-1][j]*a)%10007; cout&lt;&lt;x[k+1][m+1]; return 0;&#125; 聪明的质监员(二分答案,复杂) 当$W=0$，所有的矿石都可以被选上 当$W=\\max W_i$,所有的矿石都依法被选上。 考虑二分答案。 发现如果按照答案加过于缓慢。 那么用前缀和优化一下。 朴素版本：过了样例，但是WA 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;#define MAXN 200010int w[MAXN],v[MAXN],l[MAXN],r[MAXN];ll pren[MAXN],prev[MAXN] ;ll Y,s,sum;int n,m,mx = 1,mn = 2147483647;bool ch(int W)&#123; ll su = 0; for(ll i=1;i&lt;=m;i++)&#123; ll c = 0; ll yi = 0; // cout&lt;&lt;pos.frm&lt;&lt;&quot; &quot;&lt;&lt;pos.to&lt;&lt;endl; for(ll j=l[i];j&lt;=r[i];j++)&#123; // cout&lt;&lt;&quot;~!!!!&quot;; if(w[j]&gt;=W) &#123; c=c+1; // cout&lt;&lt;v[j]&lt;&lt;&quot; &quot;; yi = yi+ v[j]; &#125; &#125; yi = yi*c; su = su+yi; &#125; sum = llabs(su-s); if(su&gt;s) return 1; else return 0;// Y = 0,sum = 0;// memset(prev,0,sizeof prev);// memset(pren,0,sizeof pren);// for(int i=1;i&lt;=n;i++)&#123;// if(w[i]&gt;=W) pren[i] = pren[i-1]+1,prev[i] = prev[i-1]+v[i];// else pren[i] = pren[i-1],prev[i] = prev[i-1];// &#125;// for(int i=1;i&lt;=m;i++)&#123;// Y+= (pren[r[i]]-pren[l[i]-1])*(prev[r[i]]-prev[l[i]-1]);// &#125;// sum = llabs(Y-s);// if(Y&gt;s) return 1;// else return 0;&#125;int main()&#123; freopen(&quot;D:\\\\in.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; mx = max(mx,w[i]); mn = min(mn,w[i]); &#125; for(int i =1;i&lt;=m;i++) cin&gt;&gt;l[i]&gt;&gt;r[i]; int left = mn-1,right = mx+2,mid; ll ans = 0x7fffffffff; while(left&lt;=right)&#123; mid = (left+right)/2; if(ch(mid)) left = mid+1; else right = mid-1; if(sum&lt;ans) ans = sum; &#125; cout&lt;&lt;ans;&#125; 检查代码： 发现一个变量名称学错。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;#define MAXN 200010int w[MAXN],v[MAXN],l[MAXN],r[MAXN];ll pren[MAXN],prev[MAXN] ;ll Y,s,sum;int n,m,mx = 1,mn = 2147483647;bool ch(int W)&#123; Y = 0,sum = 0; memset(prev,0,sizeof prev); memset(pren,0,sizeof pren); for(int i=1;i&lt;=n;i++)&#123; if(w[i]&gt;=W) pren[i] = pren[i-1]+1,prev[i] = prev[i-1]+v[i]; else pren[i] = pren[i-1],prev[i] = prev[i-1]; &#125; for(int i=1;i&lt;=m;i++)&#123; Y+= (pren[r[i]]-pren[l[i]-1])*(prev[r[i]]-prev[l[i]-1]); &#125; sum = llabs(Y-s); if(Y&gt;s) return 1; else return 0;&#125;int main()&#123;// freopen(&quot;D:\\\\in.txt&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;m&gt;&gt;s; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;w[i]&gt;&gt;v[i]; mx = max(mx,w[i]); mn = min(mn,w[i]); &#125; for(int i =1;i&lt;=m;i++) cin&gt;&gt;l[i]&gt;&gt;r[i]; int left = mn-1,right = mx+2,mid; ll ans = 0x7fffffffff; while(left&lt;=right)&#123; mid = (left+right)/2; if(ch(mid)) left = mid+1; else right = mid-1; if(sum&lt;ans) ans = sum; &#125; cout&lt;&lt;ans;&#125; 观光公交[贪心,难] 考虑贪心。 我们的目标是最好不要让人等车。 所以预处理出来汽车到每一站的时间。就是 t[i] = \\max \\{t[i-1]+d[i],\\max\\{ \\text{arrive}[i]\\}\\} 如果还有加速器剩余，我们就选择旅客经过的数量最多的那条路减一。节约大多数人的时间。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;#define MAXN 10010int frm[MAXN],to[MAXN],tim[MAXN];int go[MAXN],dis[MAXN];int n,m,k;int main()&#123; freopen(&quot;D:\\\\in.txt&quot;,&quot;r&quot;,stdin); memset(go,0,sizeof go); cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;n;i++)&#123; cin&gt;&gt;dis[i]; &#125; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;tim[i]&gt;&gt;frm[i]&gt;&gt;to[i]; go[frm[i]] = max(tim[i],go[frm[i]]); &#125; for(int i=1;i&lt;n;i++)&#123; if(go[i]+dis[i]&lt;=go[i+1]) continue; else go[i+1] = go[i]+dis[i]; &#125; int ans = 0; for(int i=1;i&lt;=m;i++)&#123; ans+= (go[to[i]]-go[frm[i]]+1); &#125; cout&lt;&lt;ans;&#125;// 10 pts 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;int N,M,K;struct passenger&#123; int start,end;&#125;pas[100005];struct station&#123; int off,latest,arrive;&#125;sta[1005];int Dist[1005];int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;N,&amp;M,&amp;K); for(int i=1;i&lt;N;++i) scanf(&quot;%d&quot;,&amp;Dist[i]); int t; for(int i=1;i&lt;=M;++i)&#123; scanf(&quot;%d%d%d&quot;,&amp;pas[i].start,&amp;t,&amp;pas[i].end); sta[t].latest=max(sta[t].latest,pas[i].start); sta[pas[i].end].off++; &#125; int time=0; for(int i=1;i&lt;=N;++i)&#123; sta[i].arrive=time; time=max(time,sta[i].latest); time+=Dist[i]; &#125; int max_num,max_pos,tmp_num; while(K--)&#123; max_num=0; for( int i=2;i&lt;=N;++i)&#123; if(!Dist[i-1]) continue; tmp_num=0; for( int j=i;j&lt;=N;++j)&#123; tmp_num+=sta[j].off; if(sta[j].arrive&lt;=sta[j].latest) break; &#125; if(tmp_num&gt;max_num)&#123; max_num=tmp_num; max_pos=i; &#125; &#125; Dist[max_pos-1]--; for( int i=max_pos;i&lt;=N;++i)&#123; sta[i].arrive--; if(sta[i].arrive&lt;sta[i].latest) break; &#125; &#125;int ans=0; for( int i=1;i&lt;=M;++i) ans+=sta[pas[i].end].arrive-pas[i].start; printf(&quot;%d&quot;,ans); return 0;&#125; 当代的NOIP华容道[搜索,难] 5pts cout&lt;&lt;-1 50pts BFS 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;struct Node&#123; int x1,y1,x2,y2,sum;&#125;;int f[55][55][55][55];int ma[55][55];int dx[5] = &#123;-1,0,0,1&#125;;int dy[5] = &#123;0,-1,1,0&#125;;queue&lt;Node &gt; Q;int n,m,q;int ex=3,ey=2,sx=1,sy=2,tx=2,ty=2;int ans = 0x7f7f7f7f;void bfs()&#123; Q.push((Node)&#123;ex,ey,sx,sy,0&#125;); while(!Q.empty())&#123; Node now = Q.front(); int x1 = now.x1,x2=now.x2,y1 = now.y1,y2 = now.y2,sum = now.sum; Q.pop(); if(sum&gt;ans) continue; if(f[x1][y1][x2][y2]&lt;sum) continue; f[x1][y1][x2][y2] = sum; if(x2==tx &amp;&amp; y2==ty) &#123; ans = min(ans,sum); continue; &#125; for(int i=0;i&lt;4;i++)&#123; int cur_x1 = x1+dx[i]; int cur_y1 = y1+dy[i]; if(!ma[cur_x1][cur_y1] || !ma[x2][y2]) continue; if(cur_x1&lt;1 ||cur_x1&gt;n ||x2&lt;1||x2&gt;n) continue; if(cur_y1&lt;1 ||cur_y1&gt;m ||y2&lt;1||y2&gt;m) continue; if(cur_x1 == x2 &amp;&amp; cur_y1==y2)&#123; Q.push((Node)&#123;x2,y2,x1,y1,sum+1&#125;); continue; &#125; Q.push((Node)&#123;cur_x1,cur_y1,x2,y2,sum+1&#125;); &#125; &#125;&#125;void ip()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cin&gt;&gt;ma[i][j]; &#125; &#125; for(int i=1;i&lt;=q;i++)&#123; while(!Q.empty())Q.pop(); memset(f,0x7f7f7f7f,sizeof f); ans = 0x7f7f7f7f; cin&gt;&gt;ex&gt;&gt;ey&gt;&gt;sx&gt;&gt;sy&gt;&gt;tx&gt;&gt;ty; f[ex][ey][sx][sy]=0; bfs(); if(ans==0x7f7f7f7f) ans=-1; printf(&quot;%d\\n&quot;,ans); &#125;&#125;int main()&#123; freopen(&quot;D:\\\\in.txt&quot;,&quot;r&quot;,stdin); memset(f,0x7f7f7f7f,sizeof f); ip(); &#125; 如何考虑Sol? 让空白方块在图纸上乱跑不太好。 我们需要的状态其实不多。为了能让空白格子推着起始点跑，空白格子是必须在起始点旁边的。 在起始点周围（即上下左右四个方向）。状态的转移呢？——这个分两种，一种是从起始点周围转移到周围的另外一个位置，这个步数可以用一个bfs计算，另外一种是和起始点交换位置，步数很显然是1。 令$cnt[i][j][k]$表示在起始点未$(i,j)$,空白格子在目标点$k$的方向。 之后就是后继状态的转移，我们可以考虑通过连边的方式，把合法状态和它的后继状态连起来，这样状态就有传递性和连续性了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;#define MAXN 1234using namespace std;int n,m,q,edge_number,tot,ans=0x3f3f3f3f;int a[40][40],head[MAXN*MAXN+10],dis[MAXN*MAXN+10],done[MAXN*MAXN+10];int vis[40][40],cnt[40][40][5];int move_x[5]=&#123;1,-1,0,0&#125;;int move_y[5]=&#123;0,0,1,-1&#125;;struct Edge&#123;int nxt,to,dis;&#125;edge[MAXN*MAXN+10];struct Node&#123;int x,y,len;&#125;;inline void add(int from,int to,int dis)&#123; edge[++edge_number].dis=dis; edge[edge_number].nxt=head[from]; edge[edge_number].to=to; head[from]=edge_number;&#125;inline int bfs(int ax,int ay,int bx,int by,int cx,int cy)&#123; if(ax==bx&amp;&amp;ay==by) return 0; memset(vis,0,sizeof(vis)); queue&lt;Node&gt;q; q.push((Node)&#123;ax,ay,0&#125;); vis[ax][ay]=1; while(!q.empty())&#123; Node cur=q.front(); q.pop(); if(cur.x==bx&amp;&amp;cur.y==by) return cur.len; for(int i=0;i&lt;4;i++)&#123; int x=cur.x+move_x[i]; int y=cur.y+move_y[i]; if(x&lt;1||x&gt;n||y&lt;1||y&gt;m) continue; if(x==cx&amp;&amp;y==cy) continue; if(vis[x][y]||!a[x][y]) continue; q.push((Node)&#123;x,y,cur.len+1&#125;); vis[x][y]=1; &#125; &#125; return 0x3f3f3f3f;&#125; int spfa(int ax,int ay,int bx,int by,int cx,int cy)&#123; queue&lt;int&gt;q; if(bx==cx&amp;&amp;by==cy) return 0; memset(dis,0x3f,sizeof(dis)); for(int k=0;k&lt;4;k++)&#123; if(cnt[bx][by][k])&#123; dis[cnt[bx][by][k]]=bfs(ax,ay,bx+move_x[k],by+move_y[k],bx,by); q.push(cnt[bx][by][k]); done[cnt[bx][by][k]]=1; &#125; &#125; while(!q.empty())&#123; int u=q.front(); q.pop(); done[u]=0; for(int i=head[u];i;i=edge[i].nxt)&#123; int v=edge[i].to; if(dis[v]&gt;dis[u]+edge[i].dis)&#123; dis[v]=dis[u]+edge[i].dis; if(!done[v])&#123; q.push(v); done[v]=1; &#125; &#125; &#125; &#125; for(int k=0;k&lt;4;k++) if(cnt[cx][cy][k]) ans=min(ans,dis[cnt[cx][cy][k]]); if(ans==0x3f3f3f3f) return -1; else return ans;&#125;inline void init()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) for(int k=0;k&lt;4;k++) if(a[i][j]&amp;&amp;a[i+move_x[k]][j+move_y[k]]) cnt[i][j][k]=++tot; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) for(int k=0;k&lt;4;k++) if(cnt[i][j][k]) add(cnt[i][j][k],cnt[i+move_x[k]][j+move_y[k]][k^1],1); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) for(int k=0;k&lt;4;k++) for(int p=0;p&lt;4;p++) if(k!=p&amp;&amp;cnt[i][j][k]&amp;&amp;cnt[i][j][p]) add(cnt[i][j][k],cnt[i][j][p],bfs(i+move_x[k],j+move_y[k],i+move_x[p],j+move_y[p],i,j));&#125;int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;a[i][j]); init(); while(q--)&#123; int blank_x,blank_y,st_x,st_y,end_x,end_y; ans=0x3f3f3f3f; scanf(&quot;%d%d%d%d%d%d&quot;,&amp;blank_x,&amp;blank_y,&amp;st_x,&amp;st_y,&amp;end_x,&amp;end_y); printf(&quot;%d\\n&quot;,spfa(blank_x,blank_y,st_x,st_y,end_x,end_y)); &#125; return 0;&#125; 挑石头[二分答案,简单]不难写出： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;const int MAXN =100010;using namespace std;int d,n,m;int a[MAXN],l,r,mid,ans;inline int read()&#123; int x; x=0;char ch=0;bool sign=false; while(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;)&#123; sign|=(ch == &#x27;-&#x27;); ch=getchar(); &#125; while(!(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;))&#123; x=x*10+(ch^48); ch=getchar(); &#125; x=sign ? -x : x; return x;&#125;inline void print(int x)&#123; if(x&lt;0)putchar(&#x27;-&#x27;),x=-x; if(x&gt;9)print(x/10); putchar(x%10+&#x27;0&#x27;);&#125;bool judge(int x)&#123; int tot = 0; int i=0; int now = 0; while(i&lt;n+1)&#123; i++; if(a[i]-a[now]&lt;x)&#123; tot++; &#125;else now = i; &#125; if(tot&gt;m) return false; else return true;&#125;int main()&#123; d= read(),n=read(),m=read(); for(int i=1;i&lt;=n;i++)&#123; a[i] = read(); &#125; a[n+1]=d; l=1,r=d; while(l&lt;=r)&#123; mid = (l+r)/2; if(judge(mid))&#123; ans = mid , l = mid+1; &#125;else&#123; r= mid-1; &#125; &#125; print(ans); return 0;&#125; 斗地主[搜索,难] 不如不用搜索做了。 考虑$f[i][j][k][z][l]$表示一次的数码有i，两次有j，三次有k，四次的有z，王有l个最小出牌次数， 考虑一下转移 ```cppf[i][j][k][z][l] &lt;= f[i-1][j][k][z][l]+1 &lt;= f[i][j-1][k][z][l]+1 &lt;= f[i][j][k-1][z][l]+1 &lt;= f[i][j][k][z-1][l]+1 &lt;= f[i][j][k][z][l-1]+1 &lt;= f[i][j][k][z][l-2]+1 &lt;= f[i-1][j][k-1][z][l]+1 &lt;= f[i][j-1][k][z][l-1]+1 &lt;= f[i-1][j][k-1][z][l]+1 &lt;= f[i][j-1][k-1][z][l]+1 &lt;= f[i-2][j][k][z-1][l]+1 &lt;= f[i-1][j][k][z-1][l-1]+1 &lt;= f[i][j][k][z-1][l-2]+1 &lt;= f[i][j-2][k][z-1][l]+1 &lt;= f[i][j][k][z-2][l]+1 &lt;= f[i+1][j][k+1][z-1][l] &lt;= f[i+1][j+1][k-1][z][l] 123456- 还要保证拆牌。- &#96;&#96;&#96;cpp f[i][j][k][z][l]&#x3D;f[i+1][j][k+1][z−1][l] f[i][j][k][z][l]&#x3D;f[i+1][j+1][k−1][z][l] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# include &lt;cstdio&gt;# include &lt;iostream&gt;# include &lt;cstring&gt; using namespace std;int T,n,ans;int a[16];int dp[25][25][25][25][3];int num,col,coun[5];bool id;void dfs (int x)&#123; if(x&gt;=ans) return; bool f; int cnt; for (int k=1;k&lt;=3;++k) for (int i=1;i&lt;=12;++i)&#123; f=true; if(k==1) cnt=5; if(k==2) cnt=3; if(k==3) cnt=2; while (f&amp;&amp;i+cnt-1&lt;=12)&#123; for (int j=1;j&lt;=cnt;++j) if(a[i+j-1]&lt;k) &#123; f=false; break; &#125; if(f==false) continue; for (int j=1;j&lt;=cnt;++j) a[i+j-1]-=k; dfs(x+1); for ( int j=1;j&lt;=cnt;++j) a[i+j-1]+=k; cnt++; &#125; &#125; coun[1]=coun[2]=coun[3]=coun[4]=coun[5]=0; for (int i=1;i&lt;=13;++i) coun[ a[i] ]++; coun[5]=a[14]; ans=min(ans,x+dp[ coun[1] ][ coun[2] ][ coun[3] ][ coun[4] ][ coun[5] ]);&#125;void init ()&#123; int x=100; memset(dp,0x3f,sizeof(dp)); dp[0][0][0][0][0]=0; for (int z=0;z&lt;=n;++z) for (int k=0;k&lt;=n;++k) for (int i=0;i&lt;=n;++i) for (int j=0;j&lt;=n;++j) for (int l=0;l&lt;=2;++l)&#123; x=100; if(i&gt;0) x=min(x,dp[i-1][j][k][z][l]+1); if(j&gt;0) x=min(x,dp[i][j-1][k][z][l]+1); if(k&gt;0) x=min(x,dp[i][j][k-1][z][l]+1); if(z&gt;0) x=min(x,dp[i][j][k][z-1][l]+1); if(l&gt;0) x=min(x,dp[i][j][k][z][l-1]+1); if(l&gt;1) x=min(x,dp[i][j][k][z][l-2]+1); if(i&gt;0&amp;&amp;k&gt;0) x=min(x,dp[i-1][j][k-1][z][l]+1); if(l&gt;0&amp;&amp;k&gt;0) x=min(x,dp[i][j][k-1][z][l-1]+1); if(j&gt;0&amp;&amp;k&gt;0) x=min(x,dp[i][j-1][k-1][z][l]+1); if(i&gt;1&amp;&amp;z&gt;0) x=min(x,dp[i-2][j][k][z-1][l]+1); if(i&gt;0&amp;&amp;z&gt;0&amp;&amp;l&gt;0) x=min(x,dp[i-1][j][k][z-1][l-1]+1); if(z&gt;0&amp;&amp;l&gt;1) x=min(x,dp[i][j][k][z-1][l-2]+1); if(j&gt;0&amp;&amp;z&gt;0) x=min(x,dp[i][j-1][k][z-1][l]+1); if(j&gt;1&amp;&amp;z&gt;0) x=min(x,dp[i][j-2][k][z-1][l]+1); if(z&gt;1) x=min(x,dp[i][j][k][z-2][l]+1); if(z&gt;0) x=min(x,dp[i+1][j][k+1][z-1][l]); if(k&gt;0) x=min(x,dp[i+1][j+1][k-1][z][l]); dp[i][j][k][z][l]=min(dp[i][j][k][z][l],x); &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;T,&amp;n); init(); while (T--)&#123; memset(a,0,sizeof(a)); ans=n; for (int i=1;i&lt;=n;++i)&#123; scanf(&quot;%d%d&quot;,&amp;num,&amp;col); if(num==0)&#123; a[14]++; continue; &#125; if(num&gt;=3) a[num-2]++; if(num==1) a[12]++; if(num==2) a[13]++; &#125; dfs(0); printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; 逛公园[最短路计数,难] 首先，最短路计数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXM=500005,MAXN=10005;int head[MAXN],dis[MAXN],n,m,s,cnt=0,INF,f[MAXN];int mo,k;bool vis[MAXN];struct Edge&#123; int nxt,to,w;&#125;e[MAXM];void adde(int u,int v,int w)&#123; e[++cnt].nxt=head[u]; e[cnt].to=v; e[cnt].w=w; head[u]=cnt;&#125;struct Edge2&#123; int id,lenth;&#125;;struct cmp&#123; bool operator() (Edge2 e,Edge2 b)&#123; if (e.lenth!=b.lenth) return e.lenth&gt;b.lenth; else return e.id&gt;b.id; &#125;&#125;;priority_queue&lt;Edge2,vector&lt;Edge2&gt;,cmp &gt;q;void dijkstra(int s)&#123; memset(f,0,sizeof(f)); memset(vis,false,sizeof(vis)); memset(dis,127,sizeof(dis));INF=dis[0];dis[s]=0; f[1]=1; Edge2 Node; Node.id=s; Node.lenth=0; q.push(Node); while (! q.empty())&#123; Edge2 Node=q.top(); q.pop(); int u=Node.id; if (vis[u]==true) continue; vis[u]=true; for (int i=head[u];i!=0;i=e[i].nxt)&#123; int v=e[i].to; if (dis[v]-e[i].w&gt;dis[u]) &#123; dis[v]=e[i].w+dis[u]; Edge2 N; N.id=v;N.lenth=dis[v]; f[v]=f[u]%mo; q.push(N); &#125; else if (dis[v]-e[i].w==dis[u]) &#123; f[v]=(f[u]+f[v])%mo; &#125; &#125; &#125;&#125;int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while (T--) &#123; scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;k,&amp;mo); cnt=0; memset(head,0,sizeof(head)); memset(e,0,sizeof(e)); for (int i=1;i&lt;=m;i++) &#123; int u,v,w; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); adde(u,v,w); &#125; dijkstra(1); printf(&quot;%d\\n&quot;,f[n]%mo); &#125; return 0;&#125; 考虑记忆化搜索dp 判断-1，在图中有0环，这样在递归的时候会死 初始化求出最短路（考虑spfa） 枚举状态$\\text{ans}=\\sum_{i=0}^kf[i][j]$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;const int INF=0x7FFFFFFF;struct node&#123; int x; int y; node(int x1,int y1):x(x1),y(y1)&#123;&#125;&#125;;int n,m,k,p;vector&lt;node&gt;v[100007];vector&lt;node&gt;s[100007];int d[100007];int ans[100007][57];bool vis[100007][57];bool alive[100007];queue&lt;int&gt;q;queue&lt;int&gt;f;int dfs(int a,int b)&#123; if(b&lt;0)&#123; return 0; &#125;else if(vis[a][b]==1)&#123; return -INF; &#125;else if(ans[a][b]!=-1)&#123; return ans[a][b]; &#125;else&#123; vis[a][b]=1; int key=0; if(a==n)&#123; key++; &#125; for(int i=0;i&lt;v[a].size();i++)&#123; int g=v[a][i].x; int y=v[a][i].y; int u=d[g]-d[a]; if(alive[g]==0)&#123; continue; &#125; int w=dfs(g,b-(y-u)); if(w==-INF)&#123; return -INF; &#125;else&#123; key=(key+w)%p; &#125; &#125; ans[a][b]=key%p; vis[a][b]=0; return key; &#125;&#125;void safe()&#123; f.push(n); alive[n]=1; while(!f.empty())&#123; int h=f.front(); f.pop(); for(int i=0;i&lt;s[h].size();i++)&#123; int g=s[h][i].x; if(alive[g]==0)&#123; alive[g]=1; f.push(g); &#125; &#125; &#125; return;&#125;void spfa()&#123; q.push(1); d[1]=0; while(!q.empty())&#123; int h=q.front(); q.pop(); for(int i=0;i&lt;v[h].size();i++)&#123; int g=v[h][i].x; int y=v[h][i].y; if(d[h]+y&lt;d[g])&#123; d[g]=d[h]+y; q.push(g); &#125; &#125; &#125; return;&#125;int main()&#123; int t=0; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k,&amp;p); for(int i=1;i&lt;=n;i++)&#123; v[i].clear(); alive[i]=0; for(int l=0;l&lt;=k;l++)&#123; ans[i][l]=-1; vis[i][l]=0; &#125; &#125; for(int i=0;i&lt;m;i++)&#123; int a=0,b=0,c=0; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); v[a].push_back(node(b,c)); s[b].push_back(node(a,c)); &#125; for(int i=2;i&lt;=n;i++)&#123; d[i]=INF; &#125; spfa(); safe(); int z=dfs(1,k); if(z==-INF)&#123; printf(&quot;%d\\n&quot;,-1); &#125;else&#123; printf(&quot;%d\\n&quot;,z); &#125; &#125; return 0;&#125; 寻找道路[最短路径,中] 不难想到建立反向图进行BFS 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;struct ed&#123; int u; int nex;&#125;e[300000];int n,m,x,y,d[300000],fir[20000],st,s,t;bool v[20000],ok[20000],vis[20000];void add(int u,int v)&#123; e[++st].u=u; e[st].nex=fir[v]; fir[v]=st;&#125;void spfa(int b)&#123; memset(v,0,sizeof(v)); memset(d,0x3f3f,sizeof(d)); queue&lt;int&gt; q; q.push(b); v[b]=1; d[b]=0; while (!q.empty())&#123; int k=q.front(); q.pop(); v[b]=0; for (int i=fir[k];i;i=e[i].nex)&#123; int u=e[i].u,w=1; if (d[u]&gt;d[k]+w&amp;&amp;ok[e[i].u]) &#123; d[u]=d[k]+w; if (!v[u]) v[u]=1,q.push(u); &#125; &#125; &#125;&#125;void bfs(int t) &#123; memset(v,0,sizeof(v)); queue&lt;int&gt; q; q.push(t); ok[t]=v[t]=1; while (!q.empty())&#123; int k=q.front(); q.pop(); for (int i=fir[k];i;i=e[i].nex) if (!v[e[i].u])&#123; int u=e[i].u; if (!v[u]) v[u]=1,ok[u]=1,q.push(u); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for (int i=1;i&lt;=m;i++) cin&gt;&gt;x&gt;&gt;y,add(x,y); cin&gt;&gt;s&gt;&gt;t; bfs(t); for (int i=1;i&lt;=n;i++) vis[i]=ok[i]; for (int i=1;i&lt;=n;i++) if (!vis[i]) for (int j=fir[i];j;j=e[j].nex)&#123; if (ok[e[j].u]) ok[e[j].u]=0; &#125; spfa(t); if (d[s]&gt;=(0x3f3f)) cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; else cout&lt;&lt;d[s]&lt;&lt;endl; retrun 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;bits/stdc++.h&gt;#define MAXN 10010using namespace std;int n,m,s,t;struct Edge&#123; int to,nxt;&#125;e1[MAXN];struct Edge2&#123; int to,nxt;&#125;e[MAXN],e3[MAXN];int cnt1=0,cnt=0,head1[MAXN],head3[MAXN],cnt3=0,head[MAXN];void adde1(int u,int v)&#123; e1[++cnt1].to = v; e1[cnt1].nxt = head1[u]; head1[u]=cnt1;&#125;void adde(int u,int v)&#123; e[++cnt].to = v; e[cnt].nxt = head[u]; head[u]=cnt;&#125;void adde3(int u,int v)&#123; e3[++cnt3].to = v; e3[cnt3].nxt = head3[u]; head3[u]=cnt3;&#125;queue&lt;int &gt; Q;void input()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); adde1(y,x); adde3(x,y); &#125; scanf(&quot;%d %d&quot;,&amp;s,&amp;t);&#125;bool vis[MAXN];void bfs()&#123; Q.push(t); vis[t] = 1; while(!Q.empty())&#123; int u = Q.front(); Q.pop(); for(int i =head1[u];i;i = e1[i].nxt)&#123; int v = e1[i].to; if(!vis[v])&#123; vis[v] = 1; Q.push(v); &#125; &#125; &#125;&#125;bool ok[MAXN];void F()&#123; for(int q = 1;q&lt;=n;q++)&#123; ok[q] = 1; int cnter = 0; for(int i=head3[q];i;i = e3[i].nxt)&#123; cnter++; if(!vis[e3[i].to])&#123; ok[q] = 0; break; &#125; &#125; if(cnter==0) if(q!=t) ok[q] = 0; &#125;&#125;void REB(int u)&#123; if(!ok[u]) return; for(int i = head3[u];i;i = e3[i].nxt)&#123; int v = e3[i].to; if(!ok[v])&#123; continue; &#125; adde(u,v); // printf(&quot;Added %d -&gt; %d\\n&quot;,u,v); REB(v); &#125;&#125;queue&lt;int &gt; Q2;int vis2[MAXN],dis[MAXN];#define Q Q2#define vis vis2void spfa()&#123; Q.push(s); vis[s] = 1; dis[s] = 0; while(!Q.empty())&#123; int u = Q.front(); vis[u] = 0; Q.pop(); for(int i=head[u];i;i = e[i].nxt)&#123; int v = e[i].to; if(!vis[v] &amp;&amp; dis[v]&gt;dis[u]+1)&#123; dis[v] = dis[u]+1; Q.push(v); vis[v] = 1; &#125; &#125; &#125;&#125;#undef Q#undef visint main()&#123; memset(dis,0x7f7f7f,sizeof dis); input(); bfs(); F(); // if(!vis[s]) &#123; // cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; // return 0; // &#125; // spfa(); // cout&lt;&lt;dis[t]; // return 0; REB(s); spfa(); cout&lt;&lt;dis[t];&#125; 字符串[DP,中] 状态先yy出来，大概是$f[i][j][k]$表示 A 取 前i B取 前j 还有k个 的总方案。 那么考虑转移：$$\\begin{align*}\\label{2}&amp;\\forall x \\in [0,p] \\text{ that } A_{i-x} = B_{j-x} \\text{ and }A_{i-p-1} \\neq B_{j-q-1} \\\\ &amp; f[i][j][k] = \\left\\{\\begin{matrix} &amp;f[i-1][j][k] \\text{ }&amp;A_i \\neq B_j\\ &amp;\\displaystyle f[i-1][j][k]+\\sum_{t=1}^{p+1}f[i-t][j-t][k-1] &amp; A_i=b_j \\ \\end{matrix}\\right. \\end{align*} 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;inline int read()&#123; int x; x=0;char ch=0;bool sign=false; while(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;)&#123; sign|=(ch == &#x27;-&#x27;); ch=getchar(); &#125; while(!(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;))&#123; x=x*10+(ch^48); ch=getchar(); &#125; x=sign ? -x : x; return x;&#125;inline void print(int x)&#123; if(x&lt;0)putchar(&#x27;-&#x27;),x=-x; if(x&gt;9)print(x/10); putchar(x%10+&#x27;0&#x27;);&#125;#define ll long long ll f[201][201]=&#123;1&#125;,sum[201][201],n,m,ki;char a[1001],b[201];int main()&#123; n=read();m=read();ki = read();cin&gt;&gt;a&gt;&gt;b;for(int i=1;i&lt;=n;i++)&#123; for(int j=m;j&gt;=1;j--)&#123; for(int k = ki;k&gt;=1;k--)&#123; f[j][k] = (f[j][k]+(sum[j][k]=a[i-1]==b[j-1] ? sum[j-1][k]+f[j-1][k-1]:0))%1000000007; &#125; &#125; &#125; print(f[m][ki]); return 0;&#125; ### 运输计划[树上差分,难] - 可以对于每个边每局，然后找到经过最多的变。这就需要用到树上查分。 - 之后$t=\\sum_{i \\in E} i\\times t_i$ - **差分** - 差分，可以当做前缀和的逆运算。既然是逆运算，运算方法自然就是相反的了。定义差分数组diff，则运算法则为：（设原数列为a） - $\\text{diff}_i=a_i-a_{i-1}$. - **树上差分** - 要求对树上的一段路径进行操作，并询问某个点或某条边被经过的次数 - **点差分** - $u\\to v$的路径权值增加$x$: - ```cpp d[u] += x; d[v] += x; d[lca(u,v)]-=x; d[fa[lca(u,v)]]-=x; 123&#96;&#96;&#96; - 遍历时统计以每个节点为根的树的节点的权值和，就是当前节点的最终权值 - **边差分** - $u \\to v$的路径边权增加x： - ```cpp d[u] += x; d[v] += x; d[lca] -= 2*x; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 - 遍历时统计以每个节点为根的树的节点的权值和，就是当前节点到父亲节点的边的最终权值- 技术细节&#96;&#96;&#96;cpp#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;inline int read()&#123; int x; x&#x3D;0;char ch&#x3D;0;bool sign&#x3D;false; while(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;)&#123; sign|&#x3D;(ch &#x3D;&#x3D; &#39;-&#39;); ch&#x3D;getchar(); &#125; while(!(ch &lt; &#39;0&#39; || ch &gt; &#39;9&#39;))&#123; x&#x3D;x*10+(ch^48); ch&#x3D;getchar(); &#125; x&#x3D;sign ? -x : x; return x;&#125;inline void print(int x)&#123; if(x&lt;0)putchar(&#39;-&#39;),x&#x3D;-x; if(x&gt;9)print(x&#x2F;10); putchar(x%10+&#39;0&#39;);&#125;struct Edge&#123; int to,nxt,w; &#125;e[100010];int head[100010],cnt&#x3D;0;void adde(int u,int v,int w)&#123; e[++cnt].to &#x3D; v; e[cnt].nxt &#x3D; head[u]; head[u] &#x3D; cnt; e[cnt].w&#x3D; w;&#125;int fa[100010][20],dep[100010],vis[100010],d[100010],ans[100010];void dfs(int u)&#123; vis[u] &#x3D; 1; for(int i &#x3D; head[u];i;i&#x3D;e[i].nxt)&#123; int v &#x3D; e[i].to; if(fa[v][0]&#x3D;&#x3D;u || vis[v]) continue; dep[v] &#x3D; dep[u] + 1; fa[v][0] &#x3D; u; dfs(v); &#125;&#125;int lca(int x,int y)&#123; if(dep[x]&#x3D;&#x3D;1) return x; if(dep[y]&#x3D;&#x3D;1) return y; if(dep[x]&gt;dep[y]) swap(x,y); &#x2F;&#x2F; dep[x]&lt;dep[y] for(int i &#x3D; 19;i&gt;&#x3D;1;i--)&#123; if(dep[fa[y][i]]&lt;dep[x] || dep[fa[y][i]&#x3D;&#x3D;0 ]) continue; y &#x3D; fa[y][i]; if(dep[x] &#x3D;&#x3D; dep[y]) break; &#125; if(x&#x3D;&#x3D;y) return x; for(int i&#x3D;19;i&gt;&#x3D;1;i--)&#123; if(dep[fa[x][i] &#x3D;&#x3D; fa[y][i]] || dep[fa[x][i]]&#x3D;&#x3D;0) continue; x &#x3D; fa[x][i] , y &#x3D; fa[y][i]; &#125; return fa[x][0];&#125;void add(int s,int e)&#123; d[s] ++; d[e] ++; d[lca(s,e)] -&#x3D; 2;&#125;int query(int u)&#123; for(int i&#x3D;head[u];i;i &#x3D; e[i].nxt)&#123; int v &#x3D; e[i].to; if(fa[u][0] &#x3D;&#x3D; v)&#123; continue; &#125; d[u]+&#x3D;query(v); &#125; return d[u];&#125;int ll[MAXN],rr[MAXN] - AC留念（卡常卡死了）0.0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;cstring&gt;#include &lt;cstdio&gt;#define N 600005int max(int a,int b)&#123; if(a&gt;=b) return a; else return b;&#125;int min(int a,int b)&#123; if(a&lt;=b) return a; else return b;&#125;void swap(int *a,int *b)&#123;int t = *a; *a = *b;*b =t;&#125;inline int read()&#123; int x; x=0;char ch=0;bool sign=false; while(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;)&#123; sign|=(ch == &#x27;-&#x27;); ch=getchar(); &#125; while(!(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;))&#123; x=x*10+(ch^48); ch=getchar(); &#125; x=sign ? -x : x; return x;&#125;inline void print(int x)&#123; if(x&lt;0)putchar(&#x27;-&#x27;),x=-x; if(x&gt;9)print(x/10); putchar(x%10+&#x27;0&#x27;);&#125; struct Edge&#123;int v,c,nxt;&#125;e[N]; int head[N],tot; int n,k,Maxtance; int TTT[N]; int f[N][20],come[N],dep[N],d[N]; void AddEdge(int u,int v,int c)&#123; e[++tot]=(Edge)&#123;v,c,head[u]&#125;;head[u]=tot; e[++tot]=(Edge)&#123;u,c,head[v]&#125;;head[v]=tot; &#125; void dfs(int x,int fa)&#123; f[x][0]=fa,dep[x]=dep[fa]+1; for(int i=head[x];i;i=e[i].nxt)&#123; int to=e[i].v; if(to==fa)continue; d[to]=d[x]+e[i].c,TTT[to]=e[i].c; dfs(to,x); &#125; &#125; void init()&#123; for(int i=1;i&lt;=n;++i)Maxtance=max(Maxtance,d[i]); for(int i=1;i&lt;20;++i) for(int j=1;j&lt;=n;++j) f[j][i]=f[f[j][i-1]][i-1]; &#125; int Lca(int u,int v)&#123; if(dep[u]&lt;dep[v])swap(&amp;u,&amp;v); for(int i=19;i&gt;-1;--i) if(dep[f[u][i]]&gt;=dep[v]) u=f[u][i]; for(int i=19;i&gt;-1;--i) if(f[u][i]!=f[v][i]) u=f[u][i],v=f[v][i]; if(u!=v)return f[u][0]; return u; &#125; int Fans(int x)&#123; for(int i=head[x];i;i=e[i].nxt)&#123; if(e[i].v==f[x][0])continue; come[x]+=Fans(e[i].v); &#125; return come[x]; &#125; int ans; int s[N],t[N],lca[N],dis[N]; void AddVal(int i)&#123; ++come[s[i]],++come[t[i]],come[lca[i]]-=2; &#125; bool check(int mid)&#123; memset(come,false,sizeof(come)); int maxl=0,to=0; for(int i=1;i&lt;=k;++i) if(dis[i]&gt;mid) AddVal(i),maxl=max(maxl,dis[i]-mid),++to; Fans(1); for(int i=1;i&lt;=n;++i) if(come[i]&gt;=to&amp;&amp;maxl&lt;=TTT[i]) return ans=min(ans,mid); return false; &#125; int G()&#123; int l=0,r=Maxtance&lt;&lt;1,mid;ans=0x3f3f3f3f; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(check(mid))r=mid-1; else l=mid+1; &#125; return ans; &#125;int main()&#123; n=read(),k=read();int a,b,c; for(int i=1;i&lt;n;++i)&#123; a=read(),b=read(),c=read(); AddEdge(a,b,c); &#125; dfs(1,0),init(); for(int i=1;i&lt;=k;++i)&#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b);lca[i]=Lca(a,b);s[i]=a,t[i]=b; dis[i]=d[a]+d[b]-2*d[lca[i]]; &#125; print(G()); return 0;&#125; ### 蚯蚓[技巧,中] - 建立三个队就行，一个放长的，一个是切掉的长的，一个是切掉的短的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;queue &lt;ll&gt;a,b,c;bool cmp(ll x,ll y)&#123; return x&gt;y;&#125;inline int read()&#123; int x; x=0;char ch=0;bool sign=false; while(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;)&#123; sign|=(ch == &#x27;-&#x27;); ch=getchar(); &#125; while(!(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;))&#123; x=x*10+(ch^48); ch=getchar(); &#125; x=sign ? -x : x; return x;&#125;inline void print(int x)&#123; if(x&lt;0)putchar(&#x27;-&#x27;),x=-x; if(x&gt;9)print(x/10); putchar(x%10+&#x27;0&#x27;);&#125;int main()&#123; int n=read(),m=read(),q=read(),u=read(),v=read(),x,t=read(),y; ll ne[100001]; for(ll i = 1;i&lt;=n;i++) cin&gt;&gt;ne[i]; for(int i=1;i&lt;=m;i++)&#123; ll maxn = -99999999,f; if(!a.empty()) if(a.front()&gt;maxn) maxn = a.front(),f=1; if(!b.empty()) if(b.front()&gt;maxn) maxn = b.front(),f=2; if(!c.empty()) if(c.front()&gt;maxn) maxn = c.front(),f=3; if(f==1) a.pop();else if(f==2) b.pop();else if(f==3) c.pop();else while(1) printf(&quot;Error\\n&quot;); maxn+=(i-1)*q;x=maxn*u/v;y = maxn-n; if(!(i%t))cout&lt;&lt;maxn&lt;&lt;&quot; &quot;; b.push(x-i*q);c.push(y-i*q); &#125; printf(&quot;\\n&quot;) ll p=1; while(p)&#123; ll maxn=-2147483647,f; if(a.empty()&amp;&amp;b.empty()&amp;&amp;c.empty())break; if(!a.empty())if(a.front()&gt;maxn)maxn=a.front(),f=1; if(!b.empty())if(b.front()&gt;maxn)maxn=b.front(),f=2; if(!c.empty())if(c.front()&gt;maxn)maxn=c.front(),f=3; if(f==1)a.pop();if(f==2)b.pop();if(f==3)c.pop(); if(p%t==0) cout&lt;&lt;maxn+(m)*q&lt;&lt;&quot; &quot;; p++; &#125; return 0;&#125; ### 愤怒的小鸟[状压DP,中] - 先骗5pts 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int T;int n,m;int x[100010],y[100010];int solve()&#123; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;&quot;1\\n&quot;;&#125;int main()&#123; cin&gt;&gt;T; while(T--)&#123; solve(); &#125; return 0;&#125; - 最暴力的情况，就是枚举两个点，两个点，两个点……带入，时间复杂度$\\mathcal O(2^n)$ - 考虑2个点：$(c,d),(m,n)$在$y=Ax^2+Bx$上 A=\\frac{cn-md}{m^2c-c^2m}\\\\ B= \\frac{c^2n-m^2d}{mc^2-cm^2} - 大爆搜 1234567891011121314151617181920212223242526272829303132void dfs(int ans,int left)&#123; printf(&quot;--&gt; %d,%d\\n&quot;,ans,left); if(left==0) &#123; anss = min(anss,ans); return; &#125;; for(int i=1;i&lt;=n;i++)&#123; if(vis[i]) continue; vis[i]=1; for(int j=1;j&lt;=n;j++)&#123; printf(&quot;%d - %d\\n&quot;,i,j); if(vis[j]) continue; vis[j]=1; Pig pi = p[i];Pig pj = p[j]; D c=pi.x,d=pi.y,m=pj.x,n=pj.y; D a = (c*n-m*d)/(m*m*c-c*c*m); D b = (c*c*n-m*m*d)/(m*c*c-c*m*m); int tmp = left; for(int k=1;k&lt;=n;k++) &#123; if(ison(p[k],a,b))vis[k]=1,tmp--; printf(&quot;--~&gt;%d \\n&quot;,tmp); &#125; dfs(ans+1,tmp); for(int k=1;k&lt;=n;k++) &#123; if(ison(p[k],a,b)) vis[k]=0; &#125; vis[j] = 0; &#125; vis[i]=0; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std; typedef long long LL;const int MAXN = 20;int n,m,ans;bool vis[MAXN];struct node&#123; double x,y;&#125;p[MAXN];int Read()&#123; int x = 0,f = 1;char c = getchar(); while(c &gt; &#x27;9&#x27; || c &lt; &#x27;0&#x27;)&#123;if(c == &#x27;-&#x27;)f = -1;c = getchar();&#125; while(c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;)&#123;x = (x*10) + (c^48);c = getchar();&#125; return x * f;&#125;void Put(int x)&#123; if(x &gt; 9) Put(x/10); putchar(x%10^48);&#125;template &lt;typename T&gt;T Max(T x,T y)&#123;return x &gt; y ? x : y;&#125;template &lt;typename T&gt;T Min(T x,T y)&#123;return x &lt; y ? x : y;&#125;template &lt;typename T&gt;T Abs(T x)&#123;return x &lt; 0 ? -x : x;&#125;void dfs(int x,int sy,int used)&#123; if(used == ans) return; if(sy == 1)&#123; ans = Min(ans,used+1); return ; &#125; if(!sy)&#123; ans = used; return; &#125; int shot[MAXN],dz1[MAXN],tot = 0,n1 = 0; while(vis[x])x++; for(int i = x;i &lt;= n;++ i) if(!vis[i]) dz1[++n1] = i; bool f = 0; for(int j = 1;j &lt;= n1;++ j)&#123; double x1 = p[dz1[1]].x,x2 = p[dz1[j]].x,y1 = p[dz1[1]].y,y2 = p[dz1[j]].y; if(x1 == x2) continue; double a = (y1 * x2 - y2 * x1) / (x2 * x1 * x1 - x1 * x2 * x2); if(a &gt;= 0) continue; double b = (y1 - a * x1 * x1) / x1; int dz = sy; tot = 0; for(int k = 1;k &lt;= n1;++ k)&#123; if(Abs(a*p[dz1[k]].x*p[dz1[k]].x + b*p[dz1[k]].x - p[dz1[k]].y) &lt;= 0.0000001)&#123; vis[dz1[k]] = 1; shot[++tot] = dz1[k]; dz--; &#125; &#125; f = 1; dfs(x+1,dz,used+1); for(int k = 1;k &lt;= tot;++ k) vis[shot[k]] = 0; &#125; if(!f)&#123; vis[dz1[1]] = 1; dfs(x+1,sy-1,used+1); vis[dz1[1]] = 0; &#125; ans = Min(ans,used+sy); return;&#125;int main()&#123; for(int T = Read(); T ;-- T)&#123; n = Read(); m = Read(); ans = n; for(int i = 1;i &lt;= n;++ i) scanf(&quot;%lf %lf&quot;,&amp;p[i].x,&amp;p[i].y); dfs(1,n,0); Put(ans); putchar(&#x27;\\n&#x27;); &#125; return 0;&#125; - Sol：状态压缩DP–考虑状态$f[S]$ - 可以发现 - $f[0] = 0$ - $f[S | \\text{line}[i][j]] = \\min(f[S]+1)$ 打多个鸟 - $f[S | 1","categories":[],"tags":[{"name":"NOIP","slug":"NOIP","permalink":"http://example.com/tags/NOIP/"}]}],"categories":[],"tags":[{"name":"DP","slug":"DP","permalink":"http://example.com/tags/DP/"},{"name":"NOIP","slug":"NOIP","permalink":"http://example.com/tags/NOIP/"}]}